<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>双指针 - 标签 - zyz的技术博客</title>
    <link>https://YouZhiZheng.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/</link>
    <description>双指针 - 标签 | zyz的技术博客</description>
    <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>youzhizheng9@gmail.com (zyz)</managingEditor>
      <webMaster>youzhizheng9@gmail.com (zyz)</webMaster><lastBuildDate>Mon, 22 Jul 2024 21:19:02 &#43;0800</lastBuildDate><atom:link href="https://YouZhiZheng.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="self" type="application/rss+xml" /><item>
  <title>86. 分隔链表</title>
  <link>https://YouZhiZheng.github.io/posts/6fc9142/</link>
  <pubDate>Mon, 22 Jul 2024 21:19:02 &#43;0800</pubDate>
  <author>zyz</author>
  <guid>https://YouZhiZheng.github.io/posts/6fc9142/</guid>
  <description><![CDATA[题目描述(力扣):
思路: 创造两个指针，分别指向大于x的链表和小于x的链表，然后依次遍历初始链表的每个节点进行判断将其添加到对应的新链表中，最后将两个链接进行连接后返回。
代码:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* partition(ListNode* head, int x) { ListNode *h1 = new ListNode(-1); //指向小于x的节点组成的链表的头节点 ListNode *h2 = new ListNode(-1); //指向大于x的节点组成的链表的头节点 ListNode *t1, *t2; //分别指向各自链表的尾结点 t1 = h1; t2 = h2; while(head !]]></description>
</item>
</channel>
</rss>
