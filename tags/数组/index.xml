<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>数组 - 标签 - zyz的技术博客</title>
    <link>https://YouZhiZheng.github.io/tags/%E6%95%B0%E7%BB%84/</link>
    <description>数组 - 标签 | zyz的技术博客</description>
    <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>youzhizheng9@gmail.com (zyz)</managingEditor>
      <webMaster>youzhizheng9@gmail.com (zyz)</webMaster><lastBuildDate>Wed, 12 Mar 2025 17:13:58 &#43;0800</lastBuildDate><atom:link href="https://YouZhiZheng.github.io/tags/%E6%95%B0%E7%BB%84/" rel="self" type="application/rss+xml" /><item>
  <title>出行计划</title>
  <link>https://YouZhiZheng.github.io/posts/8d7c109/</link>
  <pubDate>Wed, 12 Mar 2025 17:13:58 &#43;0800</pubDate>
  <author>zyz</author>
  <guid>https://YouZhiZheng.github.io/posts/8d7c109/</guid>
  <description><![CDATA[题目思路首先，搞一发暴力，对于每个查询的时刻，根据题目所给公式计算其核酸有效时间范围，判断计划出行时间是否在这个有效时间范围内。提交后发现果然超时，只能过7个样例。
暴力法是拿每个查询的时间去依次处理每个出行计划，再判断每个计划是否可以出行。想了一下，对于暴力法没有什么大的优化点，那么能不能逆向一下处理流程呢？先处理每个出行计划，计算出每个出行计划最早和最迟做核酸的时刻，再处理每个查询的时刻。当然可以！我们可以先将每个出行计划都转化成一个时刻区间 $[start, end]$ ，
$start$表示要满足该出行计划的最早做核酸的时刻。 $end$表示要满足该出行计划的最迟做核酸的时刻。 「只要开始做核酸的时刻$q$包含在该出行计划的时刻区间里，那么必定能满足该出行计划」。
通过上面的分析可知，可以用一个$time$数组存储每个时刻（下标$i$表示时刻i）被多少个出行计划所覆盖，那么在获取要查询的时刻$q$后，就可以直接返回$time[q]$，在$O(1)$的时间内就能知道该时刻做核酸能满足多少个出行计划。
但是修改时刻区间 $[start, end]$的每个时刻对应的值时(即修改每个$time[i]，i \in [start, end]$)，仍需遍历，最坏的时间复杂度仍然为$O(2 \times 10^5 \times m)$。有什么方法可以不用遍历就能让指定区间对应的值都加1呢？那就是差分法。这样一样，就可以在$O(1)$时间内让指定区间对应的每个值都加1。
那么来梳理一遍流程：
创建一个时刻数组 $time$，用来记录每个时刻被多少个出行计划所覆盖。 将每个出行计划转化成对应的时刻区间 $[start, end]$，使用差分法让time[i]都加1，其中$i \in [start, end]$。 查询时刻$q$时，直接返回$time[q]$。 差分法差分法经常应用于「要将不同区间内的值都加上一个相同的值」。
例如，将区间$[l, r]$的每个数都加上一个$k$，只需要让 $b[l] += k, b[r+1] -= k$; 这样就可以让$a_l$到$a_r$都加上$k$，因为$a_i$的值是$b_i$的前缀和。
代码1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include &lt;bits/stdc++.]]></description>
</item>
<item>
  <title>240. 搜索二维矩阵Ⅱ</title>
  <link>https://YouZhiZheng.github.io/posts/77cc956/</link>
  <pubDate>Mon, 10 Mar 2025 09:57:17 &#43;0800</pubDate>
  <author>zyz</author>
  <guid>https://YouZhiZheng.github.io/posts/77cc956/</guid>
  <description><![CDATA[题目思路看到这题直接暴力法，但时间复杂度为$O(m*n)$，不够快。考虑到每一行的元素都是升序排列，那么可以在遍历每一行的元素时使用二分查找法，时间复杂度为$O(m * log_{}{n})$（当然也可以在遍历每一列时使用二分查找法）。
二分查找法我们只用到了行有序或列有序这两个中的一个条件，能不能同时应用这两个条件来实现更快的算法呢？设「$num$为某一行的最后一个元素」，观察发现：
如果$num$比$target$大，那么该元素所在列的后续元素都将比$target$大，所以可以直接抛弃掉这些元素。 如果$num$比$target$小，那么该元素所在行的前驱元素都将比$target$小，所以可以直接抛弃掉这些元素。 这意味着：我们可以一次性跳过当前搜索范围中的一整行或一整列，快速减少搜索空间！ 每次移动会排除一行或一列，最多移动$m+n$次，时间复杂度为 $O(m+n)$
理清了思路，那么起始点该选择哪里呢？开始时能覆盖全部值的只有右上角和右下角，那么该选哪个呢？分析一下：
右上角 值比target大时：可以跳过当前列。 值比target小时：可以跳过当前行。 右下角 值比target大时：无法跳过当前行和列。 值比target小时：target不存在。 通过分析发现，起始点只能选择右上角。这里采用的是分析行的最后一个元素，当然也可以分析列的最后一个元素，该方法就请读者自行思考了。
代码1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { int x = 0, y = matrix[0].size() - 1; while (x &lt; matrix.]]></description>
</item>
<item>
  <title>48. 旋转图像</title>
  <link>https://YouZhiZheng.github.io/posts/fa20807/</link>
  <pubDate>Sun, 09 Mar 2025 10:40:24 &#43;0800</pubDate>
  <author>zyz</author>
  <guid>https://YouZhiZheng.github.io/posts/fa20807/</guid>
  <description><![CDATA[题目思路这道题的难点主要在于不能使用辅助数组，空间复杂度必须为$O(1)$。通过观察示例，我们可以发现以下规律：
「第 $i$ 行」元素旋转到「第 $n−1−i$ 列」元素。 「第 $j$ 列」元素旋转到「第 $j$ 行」元素。 即 $(i, j)$ 要放置的位置为 $(j, n - 1 - i)$，只要我们提前使用一个临时变量$temp$来存储$matrix[j][n - 1 - i]$，即可完成$(i, j)$这个位置的旋转操作。那么$(j, n - 1 - i)$又旋转到哪个位置呢？继续应用规律，发现其旋转的位置为$(n - 1 - i, n - 1 - j)$，同样的，如果使用$temp$来存储$matrix[n - 1 - i][n - 1 - j]$，即可完成$(i, j)$和$(j, n - 1 - i)$这两个位置的旋转。按照前面的逻辑继续推理，我们可以发现：
$(i, j) → (j, n - 1 - i)$ $(j, n - 1 - i) → (n - 1 - i, n - 1 - j)$ $(n - 1 - i, n - 1 - j) → (n - 1 - j, i)$ $(n - 1 - j, i) → (i, j)$ $A→B$表示位置A的元素顺时针旋转$90°$后的位置为B。观察上面的式子，发现这四项处于一个循环中，使用一个临时变量$temp$即可完成这四个元素的原地交换！]]></description>
</item>
<item>
  <title>238. 除自身以外数组的乘积</title>
  <link>https://YouZhiZheng.github.io/posts/0ee95a7/</link>
  <pubDate>Thu, 06 Mar 2025 16:20:06 &#43;0800</pubDate>
  <author>zyz</author>
  <guid>https://YouZhiZheng.github.io/posts/0ee95a7/</guid>
  <description><![CDATA[题目思路看题第一眼想到的是先计算给定数组所有元素的乘积，然后对数组中的每个元素 $x$，将总的乘积除以 $x$ 来求得除自身值的以外数组的乘积。但当数组中出现$0$时，这个方法就失效了，且题目说明了不能使用除法。
不能使用除法，又怎么计算除自身值以外数组的乘积呢？考虑到 该数对应的乘积 =其左边的乘积 * 其右边的乘积。所以，可以通过两次遍历依次计算每个数的左右乘积即可得到答案。
代码1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; ans; // 计算每个数的左侧乘积 for(int i = 0; i &lt; nums.size(); ++i) { if(i == 0) { ans.]]></description>
</item>
<item>
  <title>41. 缺失的第一个正数</title>
  <link>https://YouZhiZheng.github.io/posts/d0633e2/</link>
  <pubDate>Thu, 06 Mar 2025 16:19:50 &#43;0800</pubDate>
  <author>zyz</author>
  <guid>https://YouZhiZheng.github.io/posts/d0633e2/</guid>
  <description><![CDATA[题目思路这道题的难点就在于要求时间复杂度为$O(n)$，空间复杂度为$O(1)$。根据题目可知我们要找到的数必定在区间 $[1, len + 1]$里，当且仅当 $1$ 到 $len$ 都出现过，要寻找的数才为$len + 1$。所以，我们可以先判断$1$ 到 $len$ 的数是否都出现过了。
由于空间复杂度必须为$O(1)$，所以借用$nums$数组本身来记录$1$ 到 $len$的出现情况，如果$[1, len]$中的某个数 x 出现过，我们就用 $nums[x - 1]$ 这个空间来记录其已经出现过了。最后再遍历 nums 数组，查看哪个正整数没有出现过，即看区间$[1, len]$中的哪个正整数没有出现过，如果 $1$ 到 $len$ 都出现过，那么缺失的第一个正整数就是 $len + 1$。
具体来说，我采用的记录方式为 若区间$[1, len]$中的 x 出现过那么将 $nums[x - 1]$ 变为 $-nums[x - 1]$(注意不要重复处理，比如两次相反就变回正数了)，后续遍历时，遍历到下标为 $i$时，若 $nums[i]$ 为负值，则表明 $i + 1$ 这个值出现过。所以，我们要先处理负值，将数组中的 全部负值 变为 $len + 1$(变为 0 或大于 len的任意数都行)。
代码1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &lt;bits/stdc++.]]></description>
</item>
<item>
  <title>53. 最大子数组和</title>
  <link>https://YouZhiZheng.github.io/posts/3930252/</link>
  <pubDate>Sat, 01 Mar 2025 10:14:12 &#43;0800</pubDate>
  <author>zyz</author>
  <guid>https://YouZhiZheng.github.io/posts/3930252/</guid>
  <description><![CDATA[题目思路看到题目说寻找最大和的连续子数组，想到了 「560. 和为 K 的子数组」 中的思路 前缀和。对于任意一个区间$[i, j]$来说其和为： $$ sum[i, j] = preSum[j] - preSum[i - 1] $$ 最大和的连续子数组就是找最大差值，让$preSum[j]$ 尽可能的大，同时让它减去的$preSum[i - 1]$尽可能的小。所以，我们只需要从左往右依次计算每个位置的前缀和，且记录下截止当前下标之前出现过的最小前缀和$min\_pre\_sum$，并用它来和当前前缀和做差，获取一个潜在的最大子数组和。
代码1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int ans = -1e5; int min_pre_sum, pre_sum; min_pre_sum = pre_sum = 0; for (const auto&amp; num : nums) { pre_sum += num; // 计算当前位置的前缀和 ans = max(ans, pre_sum - min_pre_sum); // 计算最大子数组和 min_pre_sum = min(min_pre_sum, pre_sum); // 记录已经出现的最小前缀和 } return ans; } }; ]]></description>
</item>
<item>
  <title>239. 滑动窗口最大值</title>
  <link>https://YouZhiZheng.github.io/posts/f524d2b/</link>
  <pubDate>Thu, 27 Feb 2025 19:04:09 &#43;0800</pubDate>
  <author>zyz</author>
  <guid>https://YouZhiZheng.github.io/posts/f524d2b/</guid>
  <description><![CDATA[题目思路直接暴力法，发现超时，怎么进一步优化呢？每个窗口我们都要从头到尾扫描一遍来寻找最大值，这是耗时所在，因为是寻找最大值，直接想到一种非常适合的数据结构——大根堆，堆顶就是最大值。每往右移动一次，就将新的元素加入堆中，再判断堆顶元素是否在窗口内，如果不是就移除，直到在当前窗口的元素成为堆顶。因为将一个元素加入到堆中的时间复杂度为$O(log n)$，所以算法的时间复杂度为$O(n log n)$。
能不能进一步优化呢？当然可以，在一个窗口中，假设两个元素的下标分别为$i, j$且$i &lt; j$，那么「只要$i$在窗口中，$j$也必定在窗口中」。若$nums[i] &lt; nums[j]$， 那么$nums[i]$必定不可能成为最大值，我们就可以不必存储类似$nums[i]$的值。所以，我们只需要用一个双端队列来存储「在当前窗口中可能在以后成为最大值的值的对应下标」。存储下标是因为我们后续要判断该值是否超过窗口范围。
根据前面的分析可知，该队列中的元素是递增的（因为是从左往后扫描的），元素(下标)对应的值是递减的。每次移动窗口就只需要将新元素与队尾元素对应的值进行比较，如果队尾元素对应的值小于新加元素对应的值，则将其移除（因为其对应的值不可能成为最大值了），不断地进行此项操作，直到队列为空或者新元素对应的值小于队尾元素对应值。
显然，队首元素对应的值就是当前窗口的最大值，但需要注意队首元素是否超过了窗口的范围。
这样我们只需要$O(n)$时间内就能完成此题。
代码1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { deque&lt;int&gt; dq; // 初始化, 即处理第一个窗口中的值 for (int i = 0; i &lt; k; ++i) { // 将不可能成为最大值的移除队列 while (!]]></description>
</item>
<item>
  <title>560. 和为 K 的子数组</title>
  <link>https://YouZhiZheng.github.io/posts/847b681/</link>
  <pubDate>Wed, 26 Feb 2025 10:57:50 &#43;0800</pubDate>
  <author>zyz</author>
  <guid>https://YouZhiZheng.github.io/posts/847b681/</guid>
  <description><![CDATA[题目思路直接暴力法，遍历每一个子数组查看其和是否为k，发现会超时。暴力法的时间复杂度为$O(n^2)$，瓶颈在于对于每个 $i$，我们需要枚举所有以$nums[i]$作为结尾的子数组来判断其和是否等于k，这一步是否可以优化呢？当然是可以的，考虑到子数组的连续性特性，可以通过 前缀和 来优化。
前缀和是指数组中从第一个元素到当前元素的和。假设 $pre[i]$ 为 $[0, &hellip;, i]$里所有数的和，那么 $pre[i]$ 就是前缀和。有了前缀和我们就可以用其来计算子数组的和, “子数组 [j, i] 的和为k” 就可以转化为以下等式： $$ pre[i] - pre[j - 1] = k $$ 通过变形就可以得到： $$ pre[i] - k = pre[j - 1] $$ 这说明，想要知道以 $nums[i]$ 结尾的和为 $k$ 的连续子数组的 个数 时只要统计在位置$i$之前有多少个前缀和为 $pre[i] - k$的$pre[j]$ 。所以，考虑建立哈希表，以前缀和为key，该前缀和出现次数为value，从左往右边更新哈希表边计算答案，即可在$O(n)$时间内完成此题。
需要注意的是，我们在构造哈希表时需要先插入键值对{0, 1} 且在遍历时必须先判断是否有符合条件的前缀和再往哈希表里记录当前前缀和。
为什么可以从左往右依次更新哈希表？因为$pre[i]$的值可以由 $pre[i - 1]$递推而来，即： $$ pre[i] = pre[i - 1] + nums[i] $$
为什么在构造哈希表时需要先插入键值对{0, 1}?这是为了处理特殊情况。当我们处理到位置 $i$ 时，我们想要知道的是全部以 $nums[i]$ 结尾的和为 $k$ 的连续子数组的个数，这肯定包括由[0, &hellip;, i]组成的连续子数组，它们的前缀和即为 $pre[i]$，如果不先插入键值对{0, 1}就会漏掉 $pre[i] = k$ 这一情况，导致漏算答案。]]></description>
</item>
<item>
  <title>42. 接雨水</title>
  <link>https://YouZhiZheng.github.io/posts/473665c/</link>
  <pubDate>Sun, 23 Feb 2025 14:07:10 &#43;0800</pubDate>
  <author>zyz</author>
  <guid>https://YouZhiZheng.github.io/posts/473665c/</guid>
  <description><![CDATA[题目思路接的雨水总量为每个柱子能够接的雨水之和，而每个柱子的接水量计算公式为： $$ 接水量=\min(左右两边最高柱子)−当前柱子的高度 $$ 那么直接新建两个数组 left_max 和 right_max 来存储每个柱子左右两侧的最大高度， left_max[i] 和 right_max[i] 分别表示柱子i左右两侧的最高柱子高度( left_max[i] 从左往右计算， right_max[i] 从右往左计算)，然后再通过遍历计算每个柱子的接水量累加起来即可。
上面的方法时间复杂度和空间复杂度均为$O(n)$。时间已经是最快了，那么空间上还能不能进行优化呢？上面的方法空间耗费主要来自于新建的两个存储数组。由于数组left_max是从左往右计算，数组right_max是从右往左计算，因此可以使用双指针和两个变量代替两个数组。
对于左指针left来说，其左右两侧的最大高度分别为left_left_max和 left_right_max；同理右指针有right_left_max和 right_right_max。由于$right &gt; left$，故$right\_left\_max \ge left\_left\_max$ 且 $left\_right\_max \ge right\_right\_max$，这两个不等式画个图便可直接看出。
由上面的不等式可知：
若$right\_right\_max &gt; left\_left\_max$，则必有$left\_right\_max &gt; left\_left\_max$，又left_left_max是可知的， 那么就可以计算left指向的柱子的接水量。 若$right\_right\_max &lt; left\_left\_max$，则必有$right\_left\_max &gt; right\_right\_max$，又right_right_max是可知的， 那么就可以计算right指向的柱子的接水量。 在处理了left指向的柱子后，++left向右移; 在处理了right指向的柱子后，--right向左移，直到全部柱子都被处理。
代码1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: int trap(vector&lt;int&gt;&amp; height) { int ans, left, left_max; int right, right_max; ans = left = 0; right = height.]]></description>
</item>
<item>
  <title>15. 三数之和</title>
  <link>https://YouZhiZheng.github.io/posts/df574ae/</link>
  <pubDate>Sat, 22 Feb 2025 10:59:11 &#43;0800</pubDate>
  <author>zyz</author>
  <guid>https://YouZhiZheng.github.io/posts/df574ae/</guid>
  <description><![CDATA[题目思路题目中要求找到所有 「不重复」且和为0的三元组，这个「不重复」的要求使得无法直接使用三重循环枚举所有的三元组找到答案。当然，可以直接用三重循环枚举每个答案，再使用哈希表进行去重(即先对得到的答案进行排序，比如从小到大，再转化成string后存放进unordered_set)，得到最终答案。这种做法时间复杂度和空间复杂度都很高，因此需要换一种思路来考虑这个问题。
重复的答案形式为：$(a, b, c)、(a, c, b)、(b, a, c)$&hellip;&hellip; 假设$a \le b \le c$，如果能保证只有$(a, b, c)$这种形式的答案会被枚举，就能够直接去除掉重复的答案，而不必再使用哈希表来进行去重了。
要实现这一点，就可以通过将数组中的元素从小达到进行排序，随后使用三重循环进行遍历，且 「每重循环相邻两次枚举的元素不能相同」，否则也会造成重复。例如：一个排完序后的数组为$[-1, 0, 1, 1, 2, 3]$，第一次枚举到的三元组为$(-1, 0, 1)$ ，如果第三重循环继续枚举下一个相邻元素，那么仍然为 $(-1, 0, 1)$，这就产生了重复，因此就需要将第三重的循环跳到下一个不相同的元素，即数组中的最后一个元素3，枚举三元组$(-1, 0, 3)$。
至此，我们已经对初始版本进行了空间上的优化，下面给出伪代码：
1 2 3 4 5 6 7 8 9 10 nums.sort() for first = 0 .. n-1 // 只有和上一次枚举的元素不相同，我们才会进行枚举 if first == 0 or nums[first] != nums[first-1] then for second = first+1 .. n-1 if second == first+1 or nums[second] !]]></description>
</item>
</channel>
</rss>
