<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>所有文章 - zyz的技术博客</title>
    <link>https://YouZhiZheng.github.io/posts/</link>
    <description>所有文章 | zyz的技术博客</description>
    <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>youzhizheng9@gmail.com (zyz)</managingEditor>
      <webMaster>youzhizheng9@gmail.com (zyz)</webMaster><lastBuildDate>Mon, 29 Jul 2024 21:01:40 &#43;0800</lastBuildDate><atom:link href="https://YouZhiZheng.github.io/posts/" rel="self" type="application/rss+xml" /><item>
  <title>322. 零钱兑换</title>
  <link>https://YouZhiZheng.github.io/posts/bd6092d/</link>
  <pubDate>Mon, 29 Jul 2024 21:01:40 &#43;0800</pubDate>
  <author>zyz</author>
  <guid>https://YouZhiZheng.github.io/posts/bd6092d/</guid>
  <description><![CDATA[题目描述(力扣):
什么是最优子结构
最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，可以通过子问题的最优解，推导出问题的最优解。要符合「最优子结构」，子问题间必须互相独立。
比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。
得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，「每门科目考到最高」这些子问题是互相独立，互不干扰的。
但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，不能同时达到满分，数学分数高，语文分数就会降低，反之亦然。
这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为「每门科目考到最高」的子问题并不独立，语文数学成绩户互相影响，无法同时最优，所以最优子结构被破坏。
思路: 题目说明了每种硬币数量无限，所以该问题具有最优子结构，可以用动态规划来解决。确定好用动态规划来解决后，先确定dp数组的意义，这里dp[i]存储的值就是总金额为i的最优解。接下来最重要的事情就是找到状态转移方程，dp[0] = 0，当amount大于0时，我们只需遍历给出的coins数组找到 dp[amount - coin_value] + 1 中的最小值即可(避免越界，需要先判断coin_value是否小于amount)，加一是因为要加上一个面值为coin_value的硬币。
代码:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { vector&lt;int&gt; dp(amount + 1, INT_MAX - 1); //初始化dp数组，初始值为INT_MAX - 1是因为后面有dp[i - value] + 1操作，需要避免整形溢出 dp[0] = 0; //已知的最优解 for(int i = 1; i &lt;= amount; i++) { for(int value : coins) //遍历每种硬币 { if(i - value &lt; 0) continue; //进行判断是为了避免越界 dp[i] = min(dp[i], dp[i - value] + 1); //找到总金额为 i 时的最优解 } } return dp[amount] == (INT_MAX - 1) ?]]></description>
</item>
<item>
  <title>543. 二叉树的直径</title>
  <link>https://YouZhiZheng.github.io/posts/b92556f/</link>
  <pubDate>Thu, 25 Jul 2024 21:27:01 &#43;0800</pubDate>
  <author>zyz</author>
  <guid>https://YouZhiZheng.github.io/posts/b92556f/</guid>
  <description><![CDATA[题目描述(力扣):
思路: 首先理解二叉树的直径指的是二叉树中任意两个节点之间的路径长度的最大值(最长直径不一定经过根节点)。想要找到二叉树的直径，就需要遍历每个节点，依次计算每个节点的左右子树深度之和，其中的最大值就是二叉树的直径。因为二叉树的直径大多数情况下就是根节点下的左右子树深度之和，但存在直径不经过根节点的情况，所以需要遍历每个节点，计算以该节点为根的二叉树的直径，然后取计算结果中的最大值。根据前面的分析，我们需要计算左右子树深度之和，这就需要左右子树的信息，所以选择后序遍历。
代码:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int diameterOfBinaryTree(TreeNode* root) { maxDepth(root); return maxDia; } int maxDepth(TreeNode* root) { if(root == nullptr) return 0; int lefth_h = maxDepth(root-&gt;left); int right_h = maxDepth(root-&gt;right); int Dia = lefth_h + right_h; //计算当前二叉树的直径 maxDia = max(maxDia, Dia); return lefth_h &gt; right_h?]]></description>
</item>
<item>
  <title>86. 分隔链表</title>
  <link>https://YouZhiZheng.github.io/posts/6fc9142/</link>
  <pubDate>Mon, 22 Jul 2024 21:19:02 &#43;0800</pubDate>
  <author>zyz</author>
  <guid>https://YouZhiZheng.github.io/posts/6fc9142/</guid>
  <description><![CDATA[题目描述(力扣):
思路: 创造两个指针，分别指向大于x的链表和小于x的链表，然后依次遍历初始链表的每个节点进行判断将其添加到对应的新链表中，最后将两个链接进行连接后返回。
代码:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* partition(ListNode* head, int x) { ListNode *h1 = new ListNode(-1); //指向小于x的节点组成的链表的头节点 ListNode *h2 = new ListNode(-1); //指向大于x的节点组成的链表的头节点 ListNode *t1, *t2; //分别指向各自链表的尾结点 t1 = h1; t2 = h2; while(head !]]></description>
</item>
<item>
  <title>Markdown常用语法</title>
  <link>https://YouZhiZheng.github.io/posts/d43ba28/</link>
  <pubDate>Sun, 21 Jul 2024 14:35:23 &#43;0800</pubDate>
  <author>zyz</author>
  <guid>https://YouZhiZheng.github.io/posts/d43ba28/</guid>
  <description><![CDATA[代码行内代码格式：ˋ代码内容ˋ
块内代码格式：
1 2 3 ˋˋˋmarkdown Sample text here ... ˋˋˋ 标题格式：
1 2 3 4 # 一级标题 ## 二级标题 ... ###### 六级标题 水平线格式：
1 2 3 4 水平线有三种实现方式: ___:三个连续的下划线 ---:三个连续的破折号 ***:三个连续的星号 换行分行格式：两个空格 + 回车 或 使用&lt;br&gt;
分段格式：两个回车
强调粗体格式：**加粗的内容** 也可以选择需要加粗的内容后使用快捷键Ctrl + B
斜体格式：*倾斜的内容* 或 _倾斜的内容_ 也可以选择需要加粗的内容后使用快捷键Ctrl + I
删除线格式：~~倾斜的内容~~
组合使用1 2 3 4 _**加粗和斜体**_ ~~**删除线和加粗**~~ ~~_删除线和斜体_~~ ~~_**加粗，斜体和删除线**_~~ 引用格式：&gt; + 空格 + 引用的内容]]></description>
</item>
</channel>
</rss>
