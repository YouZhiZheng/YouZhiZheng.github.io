# 出行计划


## [题目](https://www.acwing.com/problem/content/description/4458/)

![图1](/PostsImgs/Csp/25/2.png)

## 思路

首先，搞一发暴力，对于每个查询的时刻，根据题目所给公式计算其核酸有效时间范围，判断计划出行时间是否在这个有效时间范围内。提交后发现果然超时，只能过7个样例。

暴力法是拿每个查询的时间去依次处理每个出行计划，再判断每个计划是否可以出行。想了一下，对于暴力法没有什么大的优化点，那么能不能**逆向**一下处理流程呢？先处理每个出行计划，计算出每个出行计划最早和最迟做核酸的时刻，再处理每个查询的时刻。当然可以！我们可以先将每个出行计划都转化成一个**时刻区间 $[start, end]$** ，

- $start$表示要满足该出行计划的**最早**做核酸的时刻。
- $end$表示要满足该出行计划的**最迟**做核酸的时刻。

「只要开始做核酸的时刻$q$包含在该出行计划的时刻区间里，那么必定能满足该出行计划」。  

通过上面的分析可知，可以用一个$time$数组存储每个时刻（下标$i$表示时刻i）被多少个出行计划所覆盖，那么在获取要查询的时刻$q$后，就可以直接返回$time[q]$，在$O(1)$的时间内就能知道该时刻做核酸能满足多少个出行计划。

但是修改时刻区间 $[start, end]$的每个时刻对应的值时(即修改每个$time[i]，i \in [start, end]$)，仍需**遍历**，最坏的时间复杂度仍然为$O(2 \times 10^5 \times m)$。有什么方法可以不用遍历就能让指定区间对应的值都加1呢？那就是**差分法**。这样一样，就可以在$O(1)$时间内让指定区间对应的每个值都加1。

那么来梳理一遍流程：

- 创建一个时刻数组 $time$，用来记录每个时刻被多少个出行计划所覆盖。
- 将每个出行计划转化成对应的时刻区间 $[start, end]$，使用差分法让time[i]都加1，其中$i \in  [start, end]$。
- 查询时刻$q$时，直接返回$time[q]$。

### 差分法

差分法经常应用于「要将不同区间内的值都加上一个**相同**的值」。

![图1](/PostsImgs/Csp/25/2-1.png)

例如，将区间$[l, r]$的每个数都加上一个$k$，只需要让 $b[l] &#43;= k, b[r&#43;1] -= k$; 这样就可以让$a_l$到$a_r$都加上$k$，因为$a_i$的值是$b_i$的**前缀和**。

## 代码

```cpp
#include &lt;bits/stdc&#43;&#43;.h&gt;
using namespace std;

typedef long long ll;

int n, m, k, t, c, q, l, r;
int diff[200010] = { 0 }; // 构造差分数组, 因为time[i]的初始值均为0, 所以diff[i]也均为0

int main()
{
  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
  for (int i = 0; i &lt; n; &#43;&#43;i)
  {
    cin &gt;&gt; t &gt;&gt; c;
    // 计算当前场所对应的时间区间
    l = max(1, t - c - k &#43; 1);  // 计算进入该场所做核酸的最早时刻
    r = t - k;                  // 计算进入该场所做核酸的最晚时刻

    // 判断该场所是否能够进入
    if (r &gt; 0)
    {
      // 当前时间区间的每个时刻都加1, 即这个时间区间内的每个时刻能进的场所 &#43;1
      diff[l] &#43;= 1;
      diff[r &#43; 1] -= 1;
    }
  }

  // 计算每个时刻能进的场所数
  for (int i = 1; i &lt;= 200000; &#43;&#43;i)
  {
    diff[i] &#43;= diff[i - 1]; // 这里直接用diff[i] 表示 time[i]了
  }

  while (m--)
  {
    cin &gt;&gt; q;
    printf(&#34;%d\n&#34;, diff[q]);
  }
  return 0;
}

// 暴力法
// int n, m, k, flag = 0;
// int a[100010], b[100010];

// int main()
// {
//   cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
//   for (int i = 0; i &lt; n; &#43;&#43;i)
//   {
//     cin &gt;&gt; a[i] &gt;&gt; b[i];
//     if (a[i] &lt;= k)
//     {
//       flag = i;
//     }
//   }

//   int start, end;
//   // 依次处理每个查询
//   for (int i = 0; i &lt; m; &#43;&#43;i)
//   {
//     int ans = 0;
//     cin &gt;&gt; start;
//     start &#43;= k; // 计算核酸有效的开始时间
//     for (int i = flag; i &lt; n; &#43;&#43;i)
//     {
//       end = start &#43; b[i] - 1; // 计算核酸有效的最后时间
//       if (a[i] &gt;= start &amp;&amp; a[i] &lt;= end)
//       {
//         &#43;&#43;ans;
//       }
//     }
//     printf(&#34;%d\n&#34;, ans);
//   }
//   return 0;
// }
```


---

> 作者: [zyz](https://github.com/YouZhiZheng)  
> URL: https://YouZhiZheng.github.io/posts/8d7c109/  

