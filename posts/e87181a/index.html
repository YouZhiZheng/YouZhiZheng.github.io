<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="en">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>Velox_线程池模块 - zyz的技术博客</title><meta name="author" content="zyz">
<meta name="author-link" content="https://github.com/YouZhiZheng">
<meta name="description" content="概述在现代开发中，多线程可以提高程序的运行效率和响应速度，它已经成为提高应用程序性能、处理并发任务的重要手段。使用多线程需要注意线程同步、资源消耗等问题，当使用的线程数多了时，手动进行管理是十分困难的。为了解决这些问题，线程池作为一种有效的线程管理机制应运而生。
线程池会预先创建一定数量的工作线程，我们只需将待执行任务提交到线程池，线程池会负责任务的分配与执行，从而简化线程管理、减少系统频繁创建与销毁线程的开销、提高资源利用率。其核心思想是避免频繁的创建和销毁线程，减少系统开销。
主要特性完整的生命周期管理：线程池具有明确的运行状态，构成一个状态机，确保在任何时刻都处于可预期的状态。 支持暂停和恢复：在暂停状态下，线程池会继续接收新任务，但所有工作线程将暂停执行，直到线程池被恢复。 支持优雅关闭：析构函数会自动调用 shutdown函数，安全的销毁线程池，符合 RAII (Resource Acquisition Is Initialization) 原则。 支持调整工作线程数量：可以在运行时通过 increaseThreadCount 和 decreaseThreadCount 方法动态地增加或减少工作线程的数量，以适应不同的负载需求。 支持自动调整工作线程数量：引入核心线程数和最大线程数两个概念，使得线程池能在工作负载变化时自动调整线程数量。核心线程始终保留在池中，而最大线程数则限定线程池可动态扩展的上限。 支持配置文件：可以通过threadpool.yml配置文件修改线程池的相关参数（如核心线程数、最大线程数等），无需重复编译。 基础知识在正式介绍线程池模块的相关代码前，我们需要先了解一些必要的现代C&#43;&#43;编程基础知识。
std::atomicstd::atomic 是 C&#43;&#43;11 引入的模板类，用于实现多线程环境下的原子操作，从而避免数据竞争。原子操作是指一个不可被中断的操作，要么完全执行，要么完全不执行，在执行过程中不会被其他线程的调度打断。std::atomic简介
作用替代互斥锁：对于简单的计数器、标志位等共享状态，使用 std::atomic 比使用互斥锁（std::mutex）的开销更小，性能更高。锁通常会引起线程阻塞和上下文切换，而 「原子操作通常由特殊的 CPU 指令实现，属于无锁（Lock-Free）编程的范畴」。 用法1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include &lt;atomic&gt; #include &lt;iostream&gt; #include &lt;thread&gt; #include &lt;vector&gt; // 使用 std::atomic&lt;int&gt; 作为线程安全的计数器 std::atomic&lt;int&gt; counter(0); void increment() { for (int i = 0; i &lt; 10000; &#43;&#43;i) { // 原子地增加计数器，等价于 counter = counter &#43; 1 // 这个操作是线程安全的 counter." /><meta name="keywords" content='velox模块' />
  <meta itemprop="name" content="Velox_线程池模块">
  <meta itemprop="description" content="概述在现代开发中，多线程可以提高程序的运行效率和响应速度，它已经成为提高应用程序性能、处理并发任务的重要手段。使用多线程需要注意线程同步、资源消耗等问题，当使用的线程数多了时，手动进行管理是十分困难的。为了解决这些问题，线程池作为一种有效的线程管理机制应运而生。
线程池会预先创建一定数量的工作线程，我们只需将待执行任务提交到线程池，线程池会负责任务的分配与执行，从而简化线程管理、减少系统频繁创建与销毁线程的开销、提高资源利用率。其核心思想是避免频繁的创建和销毁线程，减少系统开销。
主要特性完整的生命周期管理：线程池具有明确的运行状态，构成一个状态机，确保在任何时刻都处于可预期的状态。 支持暂停和恢复：在暂停状态下，线程池会继续接收新任务，但所有工作线程将暂停执行，直到线程池被恢复。 支持优雅关闭：析构函数会自动调用 shutdown函数，安全的销毁线程池，符合 RAII (Resource Acquisition Is Initialization) 原则。 支持调整工作线程数量：可以在运行时通过 increaseThreadCount 和 decreaseThreadCount 方法动态地增加或减少工作线程的数量，以适应不同的负载需求。 支持自动调整工作线程数量：引入核心线程数和最大线程数两个概念，使得线程池能在工作负载变化时自动调整线程数量。核心线程始终保留在池中，而最大线程数则限定线程池可动态扩展的上限。 支持配置文件：可以通过threadpool.yml配置文件修改线程池的相关参数（如核心线程数、最大线程数等），无需重复编译。 基础知识在正式介绍线程池模块的相关代码前，我们需要先了解一些必要的现代C&#43;&#43;编程基础知识。
std::atomicstd::atomic 是 C&#43;&#43;11 引入的模板类，用于实现多线程环境下的原子操作，从而避免数据竞争。原子操作是指一个不可被中断的操作，要么完全执行，要么完全不执行，在执行过程中不会被其他线程的调度打断。std::atomic简介
作用替代互斥锁：对于简单的计数器、标志位等共享状态，使用 std::atomic 比使用互斥锁（std::mutex）的开销更小，性能更高。锁通常会引起线程阻塞和上下文切换，而 「原子操作通常由特殊的 CPU 指令实现，属于无锁（Lock-Free）编程的范畴」。 用法1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include &lt;atomic&gt; #include &lt;iostream&gt; #include &lt;thread&gt; #include &lt;vector&gt; // 使用 std::atomic&lt;int&gt; 作为线程安全的计数器 std::atomic&lt;int&gt; counter(0); void increment() { for (int i = 0; i &lt; 10000; &#43;&#43;i) { // 原子地增加计数器，等价于 counter = counter &#43; 1 // 这个操作是线程安全的 counter.">
  <meta itemprop="datePublished" content="2025-08-10T20:28:15+08:00">
  <meta itemprop="dateModified" content="2025-08-10T20:28:15+08:00">
  <meta itemprop="wordCount" content="4278">
  <meta itemprop="keywords" content="Velox模块"><meta property="og:url" content="https://YouZhiZheng.github.io/posts/e87181a/">
  <meta property="og:site_name" content="zyz的技术博客">
  <meta property="og:title" content="Velox_线程池模块">
  <meta property="og:description" content="概述在现代开发中，多线程可以提高程序的运行效率和响应速度，它已经成为提高应用程序性能、处理并发任务的重要手段。使用多线程需要注意线程同步、资源消耗等问题，当使用的线程数多了时，手动进行管理是十分困难的。为了解决这些问题，线程池作为一种有效的线程管理机制应运而生。
线程池会预先创建一定数量的工作线程，我们只需将待执行任务提交到线程池，线程池会负责任务的分配与执行，从而简化线程管理、减少系统频繁创建与销毁线程的开销、提高资源利用率。其核心思想是避免频繁的创建和销毁线程，减少系统开销。
主要特性完整的生命周期管理：线程池具有明确的运行状态，构成一个状态机，确保在任何时刻都处于可预期的状态。 支持暂停和恢复：在暂停状态下，线程池会继续接收新任务，但所有工作线程将暂停执行，直到线程池被恢复。 支持优雅关闭：析构函数会自动调用 shutdown函数，安全的销毁线程池，符合 RAII (Resource Acquisition Is Initialization) 原则。 支持调整工作线程数量：可以在运行时通过 increaseThreadCount 和 decreaseThreadCount 方法动态地增加或减少工作线程的数量，以适应不同的负载需求。 支持自动调整工作线程数量：引入核心线程数和最大线程数两个概念，使得线程池能在工作负载变化时自动调整线程数量。核心线程始终保留在池中，而最大线程数则限定线程池可动态扩展的上限。 支持配置文件：可以通过threadpool.yml配置文件修改线程池的相关参数（如核心线程数、最大线程数等），无需重复编译。 基础知识在正式介绍线程池模块的相关代码前，我们需要先了解一些必要的现代C&#43;&#43;编程基础知识。
std::atomicstd::atomic 是 C&#43;&#43;11 引入的模板类，用于实现多线程环境下的原子操作，从而避免数据竞争。原子操作是指一个不可被中断的操作，要么完全执行，要么完全不执行，在执行过程中不会被其他线程的调度打断。std::atomic简介
作用替代互斥锁：对于简单的计数器、标志位等共享状态，使用 std::atomic 比使用互斥锁（std::mutex）的开销更小，性能更高。锁通常会引起线程阻塞和上下文切换，而 「原子操作通常由特殊的 CPU 指令实现，属于无锁（Lock-Free）编程的范畴」。 用法1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include &lt;atomic&gt; #include &lt;iostream&gt; #include &lt;thread&gt; #include &lt;vector&gt; // 使用 std::atomic&lt;int&gt; 作为线程安全的计数器 std::atomic&lt;int&gt; counter(0); void increment() { for (int i = 0; i &lt; 10000; &#43;&#43;i) { // 原子地增加计数器，等价于 counter = counter &#43; 1 // 这个操作是线程安全的 counter.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-08-10T20:28:15+08:00">
    <meta property="article:modified_time" content="2025-08-10T20:28:15+08:00">
    <meta property="article:tag" content="Velox模块">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Velox_线程池模块">
  <meta name="twitter:description" content="概述在现代开发中，多线程可以提高程序的运行效率和响应速度，它已经成为提高应用程序性能、处理并发任务的重要手段。使用多线程需要注意线程同步、资源消耗等问题，当使用的线程数多了时，手动进行管理是十分困难的。为了解决这些问题，线程池作为一种有效的线程管理机制应运而生。
线程池会预先创建一定数量的工作线程，我们只需将待执行任务提交到线程池，线程池会负责任务的分配与执行，从而简化线程管理、减少系统频繁创建与销毁线程的开销、提高资源利用率。其核心思想是避免频繁的创建和销毁线程，减少系统开销。
主要特性完整的生命周期管理：线程池具有明确的运行状态，构成一个状态机，确保在任何时刻都处于可预期的状态。 支持暂停和恢复：在暂停状态下，线程池会继续接收新任务，但所有工作线程将暂停执行，直到线程池被恢复。 支持优雅关闭：析构函数会自动调用 shutdown函数，安全的销毁线程池，符合 RAII (Resource Acquisition Is Initialization) 原则。 支持调整工作线程数量：可以在运行时通过 increaseThreadCount 和 decreaseThreadCount 方法动态地增加或减少工作线程的数量，以适应不同的负载需求。 支持自动调整工作线程数量：引入核心线程数和最大线程数两个概念，使得线程池能在工作负载变化时自动调整线程数量。核心线程始终保留在池中，而最大线程数则限定线程池可动态扩展的上限。 支持配置文件：可以通过threadpool.yml配置文件修改线程池的相关参数（如核心线程数、最大线程数等），无需重复编译。 基础知识在正式介绍线程池模块的相关代码前，我们需要先了解一些必要的现代C&#43;&#43;编程基础知识。
std::atomicstd::atomic 是 C&#43;&#43;11 引入的模板类，用于实现多线程环境下的原子操作，从而避免数据竞争。原子操作是指一个不可被中断的操作，要么完全执行，要么完全不执行，在执行过程中不会被其他线程的调度打断。std::atomic简介
作用替代互斥锁：对于简单的计数器、标志位等共享状态，使用 std::atomic 比使用互斥锁（std::mutex）的开销更小，性能更高。锁通常会引起线程阻塞和上下文切换，而 「原子操作通常由特殊的 CPU 指令实现，属于无锁（Lock-Free）编程的范畴」。 用法1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include &lt;atomic&gt; #include &lt;iostream&gt; #include &lt;thread&gt; #include &lt;vector&gt; // 使用 std::atomic&lt;int&gt; 作为线程安全的计数器 std::atomic&lt;int&gt; counter(0); void increment() { for (int i = 0; i &lt; 10000; &#43;&#43;i) { // 原子地增加计数器，等价于 counter = counter &#43; 1 // 这个操作是线程安全的 counter.">
<meta name="application-name" content="FixIt">
<meta name="apple-mobile-web-app-title" content="FixIt"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" href="https://YouZhiZheng.github.io/posts/e87181a/" /><link rel="prev" href="https://YouZhiZheng.github.io/posts/6c7e777/" /><link rel="next" href="https://YouZhiZheng.github.io/posts/1235a2f/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Velox_线程池模块",
    "inLanguage": "en",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https:\/\/YouZhiZheng.github.io\/posts\/e87181a\/"
    },"genre": "posts","keywords": "velox模块","wordcount":  4278 ,
    "url": "https:\/\/YouZhiZheng.github.io\/posts\/e87181a\/","datePublished": "2025-08-10T20:28:15+08:00","dateModified": "2025-08-10T20:28:15+08:00","publisher": {
      "@type": "Organization",
      "name": "","logo": "https:\/\/YouZhiZheng.github.io\/favicon.ico"},"author": {
        "@type": "Person",
        "name": "zyz"
      },"description": ""
  }
  </script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/" title="zyz的技术博客"><img loading="lazy" src="/favicon.ico" alt="zyz的技术博客" data-title="zyz的技术博客" width="26" height="26" class="logo" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/><span class="header-title-text">Just Keep Learning</span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a
                class="menu-link"
                href="/archives/"
                
                
              ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> 归档</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/categories/"
                
                
              ><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden="true"></i> 分类</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/tags/"
                
                
              ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> 标签</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id="search-desktop">
            <input type="text" placeholder="搜索文章标题或内容……" id="search-input-desktop">
            <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
              <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
            </a>
            <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
              <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
            </a>
            <span class="search-button search-loading" id="search-loading-desktop">
              <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
            </span>
          </li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="zyz的技术博客"><img loading="lazy" src="/favicon.ico" alt="zyz的技术博客" data-title="zyz的技术博客" width="26" height="26" class="logo" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/><span class="header-title-text">Just Keep Learning</span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li class="search-wrapper">
            <div class="search mobile" id="search-mobile">
              <input type="text" placeholder="搜索文章标题或内容……" id="search-input-mobile">
              <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
              </a>
              <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
              </a>
              <span class="search-button search-loading" id="search-loading-mobile">
                <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
              </span>
            </div>
            <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
              取消
            </a>
          </li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/archives/"
                  
                  
                ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> 归档</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/categories/"
                  
                  
                ><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden="true"></i> 分类</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/tags/"
                  
                  
                ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> 标签</a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title="切换主题"><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span></li>
      </ul>
    </nav>
  </div>
</header><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
  </div>
  <div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
  </div><main class="container"><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label="合集"></aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span>Velox_线程池模块</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><a href="https://github.com/YouZhiZheng" title="作者"target="_blank" rel="external nofollow noopener noreferrer author" class="author"><img loading="lazy" src="/profilePicture.png" alt="zyz" data-title="zyz" width="20" height="20" class="avatar" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;zyz</a></span><span class="post-included-in">&nbsp;收录于 <a href="/categories/velox/" class="post-category" title="分类 - Velox"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> Velox</a></span></div><div class="post-meta-line"><span title="发布于 2025-08-10 20:28:15"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden="true"></i><time datetime="2025-08-10">2025-08-10</time></span>&nbsp;<span title="4278 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden="true"></i>约 4300 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden="true"></i>预计阅读 21 分钟</span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>目录</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#概述">概述</a></li>
    <li><a href="#主要特性">主要特性</a></li>
    <li><a href="#基础知识">基础知识</a>
      <ul>
        <li><a href="#stdatomic"><code>std::atomic</code></a>
          <ul>
            <li><a href="#作用">作用</a></li>
            <li><a href="#用法">用法</a></li>
            <li><a href="#常用操作">常用操作</a></li>
            <li><a href="#注意事项">注意事项</a></li>
          </ul>
        </li>
        <li><a href="#stdasync"><code>std::async</code></a>
          <ul>
            <li><a href="#作用-1">作用</a></li>
            <li><a href="#用法-1">用法</a></li>
            <li><a href="#常用操作-1">常用操作</a></li>
            <li><a href="#注意事项-1">注意事项</a></li>
          </ul>
        </li>
        <li><a href="#stdpackaged_task"><code>std::packaged_task</code></a>
          <ul>
            <li><a href="#作用-2">作用</a></li>
            <li><a href="#用法-2">用法</a></li>
            <li><a href="#常用操作-2">常用操作</a></li>
            <li><a href="#注意事项-2">注意事项</a></li>
          </ul>
        </li>
        <li><a href="#stdfuture"><code>std::future</code></a>
          <ul>
            <li><a href="#作用-3">作用</a></li>
            <li><a href="#用法-3">用法</a></li>
            <li><a href="#常用操作-3">常用操作</a></li>
            <li><a href="#注意事项-3">注意事项</a></li>
          </ul>
        </li>
        <li><a href="#stdinvoke_result_t"><code>std::invoke_result_t</code></a>
          <ul>
            <li><a href="#作用-4">作用</a></li>
            <li><a href="#用法-4">用法</a></li>
            <li><a href="#注意事项-4">注意事项</a></li>
          </ul>
        </li>
        <li><a href="#stdmove"><code>std::move</code></a>
          <ul>
            <li><a href="#作用-5">作用</a></li>
            <li><a href="#用法-5">用法</a></li>
            <li><a href="#注意事项-5">注意事项</a></li>
          </ul>
        </li>
        <li><a href="#stdforward"><code>std::forward</code></a>
          <ul>
            <li><a href="#作用-6">作用</a></li>
            <li><a href="#用法-6">用法</a></li>
            <li><a href="#注意事项-6">注意事项</a></li>
          </ul>
        </li>
        <li><a href="#stdapply"><code>std::apply</code></a>
          <ul>
            <li><a href="#作用-7">作用</a></li>
            <li><a href="#用法-7">用法</a></li>
            <li><a href="#注意事项-7">注意事项</a></li>
          </ul>
        </li>
        <li><a href="#互斥量与锁包装器">互斥量与锁包装器</a>
          <ul>
            <li><a href="#stdlock_guard"><code>std::lock_guard</code></a></li>
            <li><a href="#stdunique_lock"><code>std::unique_lock</code></a></li>
            <li><a href="#stdshared_lock"><code>std::shared_lock</code></a></li>
            <li><a href="#stdscoped_lock"><code>std::scoped_lock</code></a></li>
          </ul>
        </li>
        <li><a href="#条件变量">条件变量</a>
          <ul>
            <li><a href="#核心作用">核心作用</a></li>
            <li><a href="#工作流程">工作流程</a></li>
            <li><a href="#stdcondition_variable-主要成员函数"><code>std::condition_variable</code> 主要成员函数</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#设计概览">设计概览</a>
      <ul>
        <li><a href="#库架构">库架构</a></li>
        <li><a href="#状态转换">状态转换</a></li>
        <li><a href="#线程数量增减">线程数量增减</a></li>
        <li><a href="#任务调度与执行">任务调度与执行</a></li>
      </ul>
    </li>
    <li><a href="#主要实现">主要实现</a>
      <ul>
        <li><a href="#submit函数"><code>submit</code>函数</a></li>
        <li><a href="#工作线程执行逻辑">工作线程执行逻辑</a></li>
      </ul>
    </li>
    <li><a href="#使用示例">使用示例</a></li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><h2 id="概述" class="heading-element"><span>概述</span>
  <a href="#%e6%a6%82%e8%bf%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在现代开发中，多线程可以提高程序的运行效率和响应速度，它已经成为提高应用程序性能、处理并发任务的重要手段。使用多线程需要注意线程同步、资源消耗等问题，当使用的线程数多了时，手动进行管理是十分困难的。为了解决这些问题，<strong>线程池</strong>作为一种有效的线程管理机制应运而生。</p>
<p><strong>线程池</strong>会预先创建一定数量的工作线程，我们只需将待执行任务提交到线程池，线程池会负责任务的分配与执行，从而简化线程管理、减少系统频繁创建与销毁线程的开销、提高资源利用率。其核心思想是避免频繁的创建和销毁线程，减少系统开销。</p>
<h2 id="主要特性" class="heading-element"><span>主要特性</span>
  <a href="#%e4%b8%bb%e8%a6%81%e7%89%b9%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li><strong>完整的生命周期管理</strong>：线程池具有明确的运行状态，构成一个状态机，确保在任何时刻都处于可预期的状态。</li>
<li><strong>支持暂停和恢复</strong>：在暂停状态下，线程池会继续接收新任务，但所有工作线程将暂停执行，直到线程池被恢复。</li>
<li><strong>支持优雅关闭</strong>：析构函数会自动调用 <code>shutdown</code>函数，安全的销毁线程池，符合 RAII (Resource Acquisition Is Initialization) 原则。</li>
<li><strong>支持调整工作线程数量</strong>：可以在运行时通过 <code>increaseThreadCount</code> 和 <code>decreaseThreadCount</code> 方法动态地增加或减少工作线程的数量，以适应不同的负载需求。</li>
<li><strong>支持自动调整工作线程数量</strong>：引入核心线程数和最大线程数两个概念，使得线程池能在工作负载变化时自动调整线程数量。核心线程始终保留在池中，而最大线程数则限定线程池可动态扩展的上限。</li>
<li><strong>支持配置文件</strong>：可以通过<code>threadpool.yml</code>配置文件修改线程池的相关参数（如核心线程数、最大线程数等），无需重复编译。</li>
</ul>
<h2 id="基础知识" class="heading-element"><span>基础知识</span>
  <a href="#%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在正式介绍线程池模块的相关代码前，我们需要先了解一些必要的现代C++编程基础知识。</p>
<h3 id="stdatomic" class="heading-element"><span><code>std::atomic</code></span>
  <a href="#stdatomic" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>std::atomic</code> 是 C++11 引入的模板类，用于实现<strong>多线程环境下的原子操作</strong>，从而避免数据竞争。原子操作是指一个不可被中断的操作，要么完全执行，要么完全不执行，在执行过程中不会被其他线程的调度打断。<a href="https://zhuanlan.zhihu.com/p/649663363"target="_blank" rel="external nofollow noopener noreferrer">std::atomic简介</a></p>
<h4 id="作用" class="heading-element"><span>作用</span>
  <a href="#%e4%bd%9c%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>替代互斥锁</strong>：对于简单的计数器、标志位等共享状态，使用 <code>std::atomic</code> 比使用互斥锁（<code>std::mutex</code>）的开销更小，性能更高。锁通常会引起线程阻塞和上下文切换，而 <strong>「原子操作通常由特殊的 CPU 指令实现，属于无锁（Lock-Free）编程的范畴」</strong>。</li>
</ul>
<h4 id="用法" class="heading-element"><span>用法</span>
  <a href="#%e7%94%a8%e6%b3%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用 std::atomic&lt;int&gt; 作为线程安全的计数器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">counter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">increment</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 原子地增加计数器，等价于 counter = counter + 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 这个操作是线程安全的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">counter</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">threads</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">increment</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">t</span> <span class="p">:</span> <span class="n">threads</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// counter.load() 原子地读取当前值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Final counter value: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">counter</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 输出 100000
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="常用操作" class="heading-element"><span>常用操作</span>
  <a href="#%e5%b8%b8%e7%94%a8%e6%93%8d%e4%bd%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><code>load()</code>: 原子地读取值。</li>
<li><code>store(value)</code>: 原子地写入值。</li>
<li><code>exchange(value)</code>: 原子地替换为新值，并返回旧值。</li>
<li><code>fetch_add(arg)</code> / <code>fetch_sub(arg)</code>: 原子地加上/减去一个值，并返回旧值。（<code>+=</code> 和 <code>-=</code> 的重载是等效的，但返回新值）。</li>
<li><code>compare_exchange_weak(expected, desired)</code> / <code>compare_exchange_strong(expected, desired)</code>: 比较并交换（CAS）操作。这是原子操作的核心，它将当前值与 <code>expected</code> 比较，如果相等，则替换为 <code>desired</code> 并返回 <code>true</code>；否则，将 <code>expected</code> 更新为当前值并返回 <code>false</code></li>
</ul>
<h4 id="注意事项" class="heading-element"><span>注意事项</span>
  <a href="#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>内存序（Memory Order）</strong>：<code>std::atomic</code> 的操作可以接受一个 <code>std::memory_order</code> 参数，用来控制当前操作如何与其他线程的内存操作同步。这是 <code>std::atomic</code> 中最复杂也最关键的部分，其控制着原子操作在多线程之间的可见性和执行顺序。
<ul>
<li><code>memory_order_relaxed</code>: 最宽松的顺序，只保证操作本身的原子性，不提供任何跨线程的顺序保证。</li>
<li><code>memory_order_acquire</code>: 获取语义。在本线程中，所有后续的读写操作都不能重排到此操作之前。</li>
<li><code>memory_order_release</code>: 释放语义。在本线程中，所有之前的读写操作都不能重排到此操作之后。</li>
<li><code>memory_order_acq_rel</code>: 同时具备获取和释放语义。</li>
<li><code>memory_order_seq_cst</code>: 顺序一致性，最强的内存序，保证所有线程看到的所有原子操作都有一个全局一致的顺序。这是所有原子操作的<strong>默认值</strong>。</li>
</ul>
</li>
<li><strong>不是万能的</strong>：<code>std::atomic</code> 适用于单个变量的原子操作。如果需要保护多个变量，或者需要进行一系列复杂的操作，那么还是应该使用 <code>std::mutex</code>。</li>
<li><strong>可平凡复制</strong>：<code>std::atomic&lt;T&gt;</code> 要求类型 <code>T</code> 是可平凡复制的（Trivially Copyable），这意味着它可以用 <code>memcpy</code> 在内存中安全地复制。</li>
</ul>
<hr>
<p>看了上面的注意事项，你可能还在想 &ldquo;内存序&rdquo; 是什么鬼？有啥用？那我们就通过下面内容来了解一下：
<strong>1. 为什么需要内存序？</strong></p>
<ul>
<li>
<p><strong>编译器和 CPU 的优化</strong>
现代编译器和 CPU 为了提高性能，会对代码执行顺序进行调整（重排序），只要不改变单线程程序的语义。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="c1">// 语句 A
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>    <span class="c1">// 语句 B
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在单线程中，编译器 / CPU 可能会交换语句 A 和 B 的执行顺序，因为它们之间没有<strong>依赖关系</strong>。但在多线程环境中，这种重排序可能会导致其他线程看到不一致的内存状态。</p>
</li>
<li>
<p><strong>多处理器系统的缓存一致性问题</strong>
在多核系统中，每个 CPU 核心有自己的缓存。当一个线程修改变量时，这个修改可能先在缓存中生效，而其他核心的缓存尚未更新。如果没有适当的同步机制，其他线程可能读取到旧值。</p>
</li>
<li>
<p><strong>性能与正确性的权衡</strong>
如果所有操作都强制按顺序执行并保证全局可见性，虽然简单但会导致性能下降。内存序允许开发者根据实际需求放宽约束，提高性能。</p>
</li>
</ul>
<p><strong>2. 内存序如何解决上述问题？</strong>
C++ 提供了 6 种内存序（实际常用 4 种），通过控制 <strong>内存可见性</strong> 和 <strong>指令重排序</strong> 来平衡性能和正确性：
<strong>（1）</strong> <code>std::memory_order_relaxed</code>
该内存序只保证操作本身的原子性，不提供任何跨线程的顺序保证，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">counter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 线程 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">counter</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>  <span class="c1">// 仅保证原子性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 线程 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">counter</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>  <span class="c1">// 可能会读到 0, 也可能会读到1
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为<code>relaxed</code>不提供任何跨线程的顺序保证，所以线程2的读取到<code>counter</code>值可能为0（在加操作前读取），也可能为1（在加操作后读取）。<strong>该内存序只适用于计数器自增等无需同步的操作</strong>。</p>
<p><strong>（2）</strong><code>std::memory_order_release</code> 和 <code>std::memory_order_acquire</code>
在同一线程中<code>release</code>强制要求此操作之前的读写操作都<strong>不能重排到此操作后</strong>；在同一线程中<code>acquire</code>强制要求此操作之后的读写操作都<strong>不能重排到此操作之前</strong>。两者配合使用可以实现<strong>同步原语</strong>，是一种轻量级的同步机制。直接看示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">ready</span><span class="p">{</span><span class="nb">false</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 线程1（生产者）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">data</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// 非原子操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ready</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">// 发布数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 线程2（消费者）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ready</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">));</span> <span class="c1">// 等待数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">assert</span><span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="mi">42</span><span class="p">);</span> <span class="c1">// 必定成功
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>memory_order_release</code> 保证 <code>data=42</code> 不会重排到 <code>ready=true</code> 之后</li>
<li><code>memory_order_acquire</code> 保证 <code>assert</code> 不会重排到 <code>while</code> 之前</li>
</ul>
<p><strong>（3）</strong><code>std::memory_order_seq_cst</code>（默认）
这是原子操作中最安全的内存序，代价为性能较低，它保证了：所有线程看到的所有<strong>原子操作</strong>，具有<strong>全局统一</strong>的执行顺序（因为会更新全部核的缓存），且<strong>同一线程内的执行顺序与代码中写的顺序一致</strong>。直接看示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 线程1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">);</span> <span class="c1">// A
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">r1</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">);</span> <span class="c1">// B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//线程2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">);</span> <span class="c1">// C
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">r2</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">);</span> <span class="c1">// D
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;r1: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, r2: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在上面的代码中，合法的执行顺序只可能为下面的6种：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">A B C D
</span></span><span class="line"><span class="cl">A C B D
</span></span><span class="line"><span class="cl">A C D B
</span></span><span class="line"><span class="cl">C D A B
</span></span><span class="line"><span class="cl">C A D B
</span></span><span class="line"><span class="cl">C A B D</span></span></code></pre></td></tr></table>
</div>
</div><p><code>seq_cst</code>规定了A必须在B前面，C必须在D前面（执行顺序与代码中写的顺序一致），且当某个原子操作执行完成后，其他线程也能<strong>马上</strong>看到该操作。所以，不存在输出<code>r1: 0, r2: 0</code> 的情况，因为 <code>r1</code> 为 0 说明A已经执行（线程2能马上看到A操作的结果，即<code>x</code>的值被修改为了1），<code>r2</code>不可能为0；同理 <code>r2</code> 为 0 说明C已经执行，<code>r1</code>不可能为0。</p>
<p>==注意：==内存序十分重要和复杂，刚开始使用时推荐拷打AI老师（建议同时拷打3个），逐步积累使用经验。</p>
<h3 id="stdasync" class="heading-element"><span><code>std::async</code></span>
  <a href="#stdasync" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>std::async</code> 是一个 C++11 引入的函数模板，它以一种简单直接的方式异步地运行一个可调用对象（如函数、lambda 表达式），并返回一个 <code>std::future</code>，该 <code>std::future</code> 将在未来的某个时刻持有该异步任务的计算结果。</p>
<h4 id="作用-1" class="heading-element"><span>作用</span>
  <a href="#%e4%bd%9c%e7%94%a8-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>简化异步编程</strong>：<code>std::async</code> 是启动异步任务最简单的方法之一。它封装了线程的创建和管理，让开发者可以像调用普通函数一样启动一个并发任务，而无需手动创建 <code>std::thread</code> 对象。</li>
<li><strong>获取返回值和异常</strong>：它自动将任务的返回值或抛出的异常捕获并存入返回的 <code>std::future</code> 对象中，使得在主线程中获取结果和处理异常变得非常方便。</li>
<li><strong>抽象化线程管理</strong>：它允许运行时库（Runtime Library）根据系统负载和可用资源来决定任务的执行方式，例如是在新线程中运行还是延迟执行，从而可能实现更好的性能和资源利用。</li>
</ul>
<h4 id="用法-1" class="heading-element"><span>用法</span>
  <a href="#%e7%94%a8%e6%b3%95-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><code>std::async</code> 的基本用法是传入一个可调用对象和其所需的参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 一个耗时的任务，接收一个字符串参数并返回其长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">size_t</span> <span class="nf">string_length_task</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Task running in thread: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">my_string</span> <span class="o">=</span> <span class="s">&#34;Hello, C++ Concurrency!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Main thread: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 启动异步任务。my_string 被复制或移动到任务中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 使用 std::launch::async 策略确保任务在新线程中执行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">size_t</span><span class="o">&gt;</span> <span class="n">fut</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="n">string_length_task</span><span class="p">,</span> <span class="n">my_string</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Task launched. Main thread continues working...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 主线程可以执行其他工作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Waiting for result from async task...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用 fut.get() 会阻塞，直到任务完成并返回结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">size_t</span> <span class="n">length</span> <span class="o">=</span> <span class="n">fut</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;The length of the string is: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">length</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="常用操作-1" class="heading-element"><span>常用操作</span>
  <a href="#%e5%b8%b8%e7%94%a8%e6%93%8d%e4%bd%9c-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><code>std::async</code> 本身是一个函数，其操作就是调用它。关键在于如何配置它的行为，这通过启动策略（launch policy）参数来控制：</p>
<ul>
<li>
<p><strong><code>std::async(std::launch::async, f, args...)</code></strong>:</p>
<ul>
<li><strong>行为</strong>: 保证可调用对象 <code>f</code> 在一个新的线程上异步执行，类似于创建了一个 <code>std::thread</code>。</li>
<li><strong>效果</strong>: 任务会立即开始（或尽快由操作系统调度），与调用者并发执行。</li>
</ul>
</li>
<li>
<p><strong><code>std::async(std::launch::deferred, f, args...)</code></strong>:</p>
<ul>
<li><strong>行为</strong>: 任务被延迟执行。它不会立即启动，而是在返回的 <code>std::future</code> 上首次调用 <code>get()</code> 或 <code>wait()</code> 时，才会在<strong>调用 <code>get()</code> 或 <code>wait()</code> 的那个线程</strong>上同步执行。</li>
<li><strong>效果</strong>: 没有并发，只是将函数的执行推迟了。</li>
</ul>
</li>
<li>
<p><strong><code>std::async(f, args...)</code></strong> (不指定策略，使用默认值):</p>
<ul>
<li><strong>行为</strong>: 这是默认策略，等价于 <code>std::launch::async | std::launch::deferred</code>。实现可以自由选择是在新线程中立即执行，还是延迟执行。</li>
<li><strong>效果</strong>: 行为不确定，取决于具体的标准库实现和当时的系统状态。这可能导致性能问题或意外的阻塞。</li>
</ul>
</li>
</ul>
<h4 id="注意事项-1" class="heading-element"><span>注意事项</span>
  <a href="#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li>
<p><strong>显式指定启动策略</strong>：由于默认策略的行为不确定，强烈建议总是显式指定 <code>std::launch::async</code> 或 <code>std::launch::deferred</code>。<code>std::launch::async</code> 是最常用的，因为它能保证真正的并发。</p>
</li>
<li>
<p><strong><code>future</code> 的析构函数行为</strong>：如果由 <code>std::async</code> 返回的 <code>std::future</code> 在其关联的任务尚未完成时被销毁，该 <code>future</code> 的析构函数<strong>会阻塞</strong>，直到任务执行完毕。这是一种安全机制，防止程序在后台线程仍在运行时意外退出，但也可能导致非预期的等待。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">might_block</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// fut 是局部变量，在函数返回时会被销毁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果任务还在运行，析构函数会阻塞在此处
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">fut</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[]{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// &lt;- 此处可能阻塞
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>参数传递</strong>：传递给 <code>std::async</code> 的参数会<strong>被复制或移动</strong>到任务的内部存储中。如果想通过引用传递参数以避免拷贝，并希望在任务中修改原始值，需要使用 <code>std::ref</code> 或 <code>std::cref</code> 进行包装。</p>
</li>
</ul>
<h3 id="stdpackaged_task" class="heading-element"><span><code>std::packaged_task</code></span>
  <a href="#stdpackaged_task" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>std::packaged_task</code> 是一个 C++11 引入的模板类，它将一个可调用对象（函数、lambda 等）包装起来，使其可以被异步调用。它的核心功能是<strong>将任务的定义与任务的执行以及其未来结果分离开来</strong>。</p>
<h4 id="作用-2" class="heading-element"><span>作用</span>
  <a href="#%e4%bd%9c%e7%94%a8-2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>解耦任务与线程</strong>：<code>std::packaged_task</code> 允许你创建一个“任务包”，这个包内含一个要执行的操作。你可以稍后决定这个任务在哪个线程上执行，甚至可以将其存储在一个队列中，由一个线程池来处理。</li>
<li><strong>连接可调用对象与 <code>std::future</code></strong>：它像一个桥梁，一端连接着你的函数代码，另一端通过 <code>get_future()</code> 方法提供一个 <code>std::future</code> 对象。当这个任务包被执行时，其返回值或异常会自动被存入关联的 <code>std::future</code> 中。</li>
<li><strong>构建线程池和任务队列</strong>：它是实现线程池、任务调度器等高级并发模式的关键组件。你可以创建一堆 <code>packaged_task</code>，把它们放入一个队列，然后让工作线程从队列中取出任务并执行。</li>
</ul>
<h4 id="用法-2" class="heading-element"><span>用法</span>
  <a href="#%e7%94%a8%e6%b3%95-2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>基本流程分为三步：包装任务、获取 <code>future</code>、执行任务。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp"> </span><span class="c1">// for std::packaged_task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 任务：计算两个整数的和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 包装任务：创建一个 packaged_task，其签名为 int(int, int)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 获取 future：在任务执行前，获取与之关联的 future
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result_future</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 执行任务：决定在何处、何时执行任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里我们把它移动到一个新线程中执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// packaged_task 是不可复制的，只能移动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">task_thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Task has been sent to a thread. Waiting for the result...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 从 future 中获取结果（会阻塞直到任务完成）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">result_future</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;The result is: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">task_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span> <span class="c1">// 等待线程执行完毕
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="常用操作-2" class="heading-element"><span>常用操作</span>
  <a href="#%e5%b8%b8%e7%94%a8%e6%93%8d%e4%bd%9c-2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>构造函数 <code>std::packaged_task&lt;Signature&gt;(callable)</code></strong>:
<ul>
<li>用一个可调用对象 <code>callable</code> 来创建一个任务包。<code>Signature</code> 是函数的签名，例如 <code>int(int, double)</code>。</li>
</ul>
</li>
<li><strong><code>get_future()</code></strong>:
<ul>
<li>返回一个与该任务关联的 <code>std::future</code> 对象。<strong>注意：<code>get_future()</code> 只能调用一次</strong>。</li>
</ul>
</li>
<li><strong><code>operator()</code></strong>:
<ul>
<li>执行被包装的任务。调用 <code>task(args...)</code> 就会执行内部的可调用对象。任务的返回值（或异常）会被自动存入 <code>future</code>。</li>
</ul>
</li>
<li><strong><code>make_ready_at_thread_exit()</code></strong>:
<ul>
<li>在任务执行后，调用此方法可以使任务的共享状态在线程退出时才变为 <code>ready</code>。这在处理线程局部变量（thread-local variables）时非常有用。</li>
</ul>
</li>
<li><strong><code>reset()</code></strong>:
<ul>
<li>重置 <code>packaged_task</code> 的状态，使其可以被再次执行。它会释放之前的结果，并重新与一个新的 <code>std::future</code> 关联（需要再次调用 <code>get_future()</code>）。</li>
</ul>
</li>
</ul>
<h4 id="注意事项-2" class="heading-element"><span>注意事项</span>
  <a href="#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9-2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>移动语义（Move-Only）</strong>：<code>std::packaged_task</code> 是一个只移类型（Move-Only），它不可复制。这意味着你不能将其拷贝到多个地方，只能通过 <code>std::move</code> 来转移其所有权，例如将其存入容器或传递给线程。</li>
<li><strong>一次性的 <code>get_future()</code></strong>：与 <code>std::promise</code> 类似，一个 <code>packaged_task</code> 实例的 <code>get_future()</code> 方法只能被成功调用一次。再次调用会抛出 <code>std::future_error</code>。</li>
</ul>
<h3 id="stdfuture" class="heading-element"><span><code>std::future</code></span>
  <a href="#stdfuture" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>std::future</code> 提供了一种访问<strong>异步操作结果</strong>的机制。当你启动一个异步任务时（例如，通过 <code>std::async</code>，<code>std::packaged_task</code> 或 <code>std::promise</code>），你会得到一个 <code>std::future</code> 对象。这个 <code>future</code> 对象在未来的某个时刻会持有该异步任务的计算结果或抛出的异常。</p>
<h4 id="作用-3" class="heading-element"><span>作用</span>
  <a href="#%e4%bd%9c%e7%94%a8-3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>获取异步结果</strong>：主线程可以随时通过 <code>future</code> 对象查询异步任务是否完成，并获取其返回值，而无需自己手动管理线程和共享状态。</li>
<li><strong>线程同步</strong>：<code>future</code> 的 <code>.get()</code> 或 <code>.wait()</code> 方法会阻塞当前线程，直到异步任务完成。这是一种简单的线程同步方式。</li>
<li><strong>异常传递</strong>：如果异步任务在执行过程中抛出异常，该异常会被捕获并存储在 <code>future</code> 对象中。当主线程调用 <code>.get()</code> 时，该异常会被重新抛出。</li>
</ul>
<h4 id="用法-3" class="heading-element"><span>用法</span>
  <a href="#%e7%94%a8%e6%b3%95-3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>最常见的用法是与 <code>std::async</code> 配合使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 一个可能耗时较长的计算任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">calculate_something</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="cm">/* some error condition */</span> <span class="nb">false</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&#34;Calculation failed!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">123</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用 std::async 启动一个异步任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// std::launch::async 策略保证任务在一个新线程上运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">fut</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="n">calculate_something</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Doing other work in main thread...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 在主线程中可以做其他事情 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Waiting for the result...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 调用 .get() 来获取结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果任务尚未完成，此调用会阻塞当前线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">fut</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;The result is: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Exception from async task: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="常用操作-3" class="heading-element"><span>常用操作</span>
  <a href="#%e5%b8%b8%e7%94%a8%e6%93%8d%e4%bd%9c-3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><code>get()</code>: 等待异步任务完成并返回其结果。如果任务抛出异常，<code>get()</code> 会重新抛出该异常。<strong>注意：<code>get()</code> 只能调用一次</strong>。</li>
<li><code>wait()</code>: 等待异步任务完成，但不获取结果。</li>
<li><code>wait_for()</code> / <code>wait_until()</code>: 等待一段时间或直到某个时间点。</li>
<li><code>valid()</code>: 检查 <code>future</code> 对象是否与一个共享状态关联。调用 <code>get()</code> 后，<code>future</code> 会变为 invalid。</li>
</ul>
<h4 id="注意事项-3" class="heading-element"><span>注意事项</span>
  <a href="#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9-3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong><code>get()</code> 的一次性</strong>：<code>std::future</code> 的 <code>get()</code> 成员函数只能被调用一次。因为结果（或异常）可能会被移动出来，而不是复制。再次调用会抛出异常。如果需要多次访问结果，应该使用 <code>std::shared_future</code>。</li>
<li><strong><code>std::async</code> 的析构行为</strong>：如果一个由 <code>std::async</code> 返回的 <code>std::future</code> 对象在析构时，其关联的异步任务还未完成，那么这个析构函数会阻塞，直到任务完成。这被称为“延迟销毁”，有时会造成意想不到的阻塞。</li>
</ul>
<h3 id="stdinvoke_result_t" class="heading-element"><span><code>std::invoke_result_t</code></span>
  <a href="#stdinvoke_result_t" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>std::invoke_result_t</code> 是 C++17 中引入的类型别名，用于在<strong>编译期</strong>推断一个可调用对象（函数、函数指针、lambda 表达式、成员函数指针、函数对象等）在以特定参数调用时，其返回值的类型。它是 <code>std::invoke_result&lt;F, Args...&gt;::type</code> 的简写形式。</p>
<h4 id="作用-4" class="heading-element"><span>作用</span>
  <a href="#%e4%bd%9c%e7%94%a8-4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>编译期类型推导</strong>：它允许你在编写模板或泛型代码时，能够提前知道一个函数调用将返回什么类型，而无需实际执行该调用。</li>
<li><strong>SFINAE 和元编程</strong>：在模板元编程中，它可以用于根据函数返回类型进行 SFINAE（Substitution Failure Is Not An Error，替换失败并非错误）判断，或者定义依赖于函数返回类型的变量和数据结构。</li>
</ul>
<h4 id="用法-4" class="heading-element"><span>用法</span>
  <a href="#%e7%94%a8%e6%b3%95-4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Foo</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">bar</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mf">1.0</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 推断普通函数调用的返回类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">using</span> <span class="n">Result1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">add</span><span class="p">),</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">Result1</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 推断 lambda 表达式的返回类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">lambda</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">{</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">()};</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">Result2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">lambda</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">Result2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 推断成员函数指针的返回类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 注意：推导成员函数指针返回类型时，第一个参数应为能绑定该成员函数的对象类型，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如 T&amp;, T*, 或 std::reference_wrapper&lt;T&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">using</span> <span class="n">Result3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">bar</span><span class="p">),</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">Result3</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;All types deduced correctly.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="注意事项-4" class="heading-element"><span>注意事项</span>
  <a href="#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9-4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>非静态成员函数</strong>：对于非静态的成员函数，<code>invoke_result_t</code>只能使用其函数指针才能进行返回值类型推导，因为<code>类名::成员函数名</code>不是完整的成员限定表达式，只有加了<code>&amp;</code>成为成员函数指针，才能脱离类定义被使用。</li>
<li><strong>C++17标准</strong>：<code>std::invoke_result_t</code> 是 C++17 的特性，它在处理某些复杂情况（如成员函数指针）时不如 <code>std::invoke_result</code> 强大且已被 C++20 废弃。</li>
</ul>
<h3 id="stdmove" class="heading-element"><span><code>std::move</code></span>
  <a href="#stdmove" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>std::move</code> 是一个标准库函数，它的主要作用是<strong>声明</strong>一个对象可以被“移动”，即其资源可以被窃取。它本身并不执行任何移动操作，真正的移动操作是由移动构造函数或移动赋值运算符完成的。</p>
<h4 id="作用-5" class="heading-element"><span>作用</span>
  <a href="#%e4%bd%9c%e7%94%a8-5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>启用移动语义</strong>：将左值（有名字、可以取地址的对象）转换为右值，从而使得可以调用对象的移动构造函数或移动赋值运算符，避免不必要的深拷贝，提升性能。</li>
<li><strong>转移所有权</strong>：对于像 <code>std::unique_ptr</code>、<code>std::thread</code> 这种只移类型（Move-Only Type），<code>std::move</code> 是转移其所有权的唯一方式。</li>
</ul>
<h4 id="用法-5" class="heading-element"><span>用法</span>
  <a href="#%e7%94%a8%e6%b3%95-5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> </span><span class="c1">// for std::move
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">&#34;hello&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str2</span> <span class="o">=</span> <span class="s">&#34;world&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Before move:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;str1: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">str1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;str2: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">str2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里，std::move(str1) 将左值 str1 转换为右值引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这使得 std::string 的移动赋值运算符被调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">str2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">str1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">After move:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;str1: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">str1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// str1 处于有效的、但未指定的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;str2: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">str2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// str2 获得了 str1 的资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用 vector 的移动构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">vec1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">Vector size after move:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;vec1 size: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">vec1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 通常为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;vec2 size: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">vec2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="注意事项-5" class="heading-element"><span>注意事项</span>
  <a href="#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9-5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>被移动后的对象状态</strong>：使用 <code>std::move</code> 后，原对象处于“有效的、但未指定的状态”（valid but unspecified state）。这意味着你不能对其状态做任何假设（例如，它可能为空，也可能不是），但你可以安全地对其进行销毁或重新赋值。在对其重新赋值之前，不应再使用它。</li>
<li><strong>不要对 <code>const</code> 对象使用 <code>std::move</code></strong>：对 <code>const</code> 对象 <code>std::move</code> 会得到一个 <code>const</code> 类型的右值引用，这通常会退化为一次拷贝操作，因为 <code>const</code> 对象是不可修改的，其资源无法被移动。</li>
<li><strong>仅在需要转移所有权时使用</strong>：<code>std::move</code> 的名字有一定误导性，它更像是一个“转换”或“允许移动”的请求。只有当你确定不再需要原对象，并希望将其资源转移给新对象时，才应该使用它。</li>
</ul>
<h3 id="stdforward" class="heading-element"><span><code>std::forward</code></span>
  <a href="#stdforward" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>std::forward</code> 是一个条件转换函数，主要用于模板编程中的“完美转发”（Perfect Forwarding）。它根据模板参数的类型（左值引用或右值引用），将函数参数以原始的值类别（左值或右值）转发给另一个函数。</p>
<h4 id="作用-6" class="heading-element"><span>作用</span>
  <a href="#%e4%bd%9c%e7%94%a8-6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>保持值类别</strong>：在模板函数中，函数参数会丢失其原始的值类别信息（都变成了左值）。<code>std::forward</code> 的作用是恢复这个信息，如果原始传入的是右值，就转发为右值；如果原始传入的是左值，就转发为左值。</li>
<li><strong>实现完美转发</strong>：这使得我们可以编写一个模板函数作为“中转站”，它能接收任意类型的参数，并将其无损地（不改变值类别，不产生额外拷贝）传递给下一个函数。</li>
</ul>
<h4 id="用法-6" class="heading-element"><span>用法</span>
  <a href="#%e7%94%a8%e6%b3%95-6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>它通常用在接受转发引用（Forwarding Reference，也叫万能引用 Universal Reference）的模板函数中。转发引用是一种特殊的模板参数形式 <code>T&amp;&amp;</code>，其中 <code>T</code> 是一个需要推导的类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> </span><span class="c1">// for std::forward
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 目标函数，有针对左值引用和右值引用的重载
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">overloaded_func</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Called with lvalue reference&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">overloaded_func</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Called with rvalue reference&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 一个“转发”或“包装”的模板函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">arg</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在这里，不管 arg 原始是左值还是右值，它本身都是一个有名字的左值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果直接调用 overloaded_func(arg)，永远都会调用左值版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用 std::forward 来保持原始的值类别
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">overloaded_func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">wrapper</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>         <span class="c1">// i 是左值，T 被推导为 int&amp;，wrapper 转发一个左值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">wrapper</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>       <span class="c1">// 100 是右值，T 被推导为 int，wrapper 转发一个右值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">wrapper</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">i</span><span class="p">));</span> <span class="c1">// std::move(i) 是右值，T 被推导为 int，wrapper 转发一个右值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面的示例中，T的类型被推导出来后，<code>wrapper</code>函数的参数就为 <strong>推导的类型 + <code>&amp;&amp;</code></strong>，这时会发生引用坍缩，参数类型会变为正确的类型。</p>
<h4 id="注意事项-6" class="heading-element"><span>注意事项</span>
  <a href="#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9-6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>必须与转发引用配合</strong>：<code>std::forward</code> 只应在接受转发引用（<code>T&amp;&amp;</code>）的上下文中使用。如果用在普通的值传递或非转发引用的参数上，行为可能不符合预期。</li>
<li><strong>模板参数 <code>T</code> 是关键</strong>：<code>std::forward&lt;T&gt;</code> 的模板参数 <code>T</code> 必须是函数模板推导出的类型，它包含了原始参数是左值还是右值的信息。</li>
</ul>
<h3 id="stdapply" class="heading-element"><span><code>std::apply</code></span>
  <a href="#stdapply" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>std::apply</code> 是 C++17 引入的函数，它允许你使用一个元组（<code>std::tuple</code>）或类似元组的对象（如 <code>std::pair</code>, <code>std::array</code>）的元素作为参数来调用一个可调用对象。</p>
<h4 id="作用-7" class="heading-element"><span>作用</span>
  <a href="#%e4%bd%9c%e7%94%a8-7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>解包元组</strong>：将一个元组中的元素“解开”，并按顺序作为独立的参数传递给一个函数。这在泛型编程和处理可变参数模板时非常有用。</li>
<li><strong>简化函数调用</strong>：当你需要调用的函数的参数被存储在一个元组中时，<code>std::apply</code> 提供了一种简洁、优雅的方式来执行调用，而无需手动索引元组的每个元素。</li>
</ul>
<h4 id="用法-7" class="heading-element"><span>用法</span>
  <a href="#%e7%94%a8%e6%b3%95-7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;tuple&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp"> </span><span class="c1">// for std::apply
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print_sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; + &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; + &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">MyStruct</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Processing &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; with ID &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 调用普通函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">apply</span><span class="p">(</span><span class="n">print_sum</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span> <span class="c1">// 等价于 print_sum(10, 20, 30)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 调用 lambda 表达式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">lambda</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Product: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">apply</span><span class="p">(</span><span class="n">lambda</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">));</span> <span class="c1">// 使用 std::pair
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 调用成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">MyStruct</span> <span class="n">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">member_args</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;Widget&#34;</span><span class="p">,</span> <span class="mi">123</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">apply</span><span class="p">([</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">){</span> <span class="n">obj</span><span class="p">.</span><span class="n">process</span><span class="p">(</span><span class="n">params</span><span class="p">...);</span> <span class="p">},</span> <span class="n">member_args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 或者更直接的方式（需要 C++17 的扩展）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// std::apply(&amp;MyStruct::process, std::tuple_cat(std::make_tuple(&amp;obj), member_args));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="注意事项-7" class="heading-element"><span>注意事项</span>
  <a href="#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9-7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>C++17 标准</strong>：<code>std::apply</code> 是 C++17 的特性。在之前的版本中，需要手动编写复杂的模板元编程代码（通常涉及索引序列 <code>std::index_sequence</code>）来实现类似的功能。</li>
<li><strong>参数顺序</strong>：元组中的元素会严格按照从 0 开始的索引顺序，依次映射到函数的第一个、第二个、第三个&hellip;参数。</li>
<li><strong>兼容性</strong>：任何支持 <code>std::get</code> 和 <code>std::tuple_size</code> 的类（Tuple-like-object）都可以与 <code>std::apply</code> 一起使用。这包括 <code>std::tuple</code>, <code>std::pair</code> 和 <code>std::array</code>。</li>
</ul>
<h3 id="互斥量与锁包装器" class="heading-element"><span>互斥量与锁包装器</span>
  <a href="#%e4%ba%92%e6%96%a5%e9%87%8f%e4%b8%8e%e9%94%81%e5%8c%85%e8%a3%85%e5%99%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在C++17标准下，常用的互斥量如下所示：</p>
<table>
<thead>
<tr>
<th>互斥锁类型</th>
<th>简介</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::mutex</code></td>
<td>最基本的互斥锁，不能递归锁定，一个线程加锁后，其他任何线程（包括自己）都不能再次加锁</td>
<td>通用互斥锁，保护绝大多数常规的临界区</td>
</tr>
<tr>
<td><code>std::recursive_mutex</code></td>
<td>允许同一个线程多次加锁的互斥锁，需手动解锁相同次数后，其他线程才能获取</td>
<td>需要在递归函数或同一线程中多次加锁的场景</td>
</tr>
<tr>
<td><code>std::timed_mutex</code></td>
<td>带计时的互斥锁，超时自动解锁</td>
<td>当你不希望线程无限期地等待一个锁时，如线程池任务调度、定时任务等</td>
</tr>
<tr>
<td><code>std::recursive_timed_mutex</code></td>
<td>结合递归锁和超时锁的特性的互斥锁</td>
<td>既需要递归锁定又要求支持超时的场景，如复杂嵌套逻辑下的任务控制</td>
</tr>
<tr>
<td><code>std::shared_mutex</code></td>
<td>读写锁，多个线程可共享读，写互斥</td>
<td>读多写少场景，如缓存、配置、数据库读接口等</td>
</tr>
</tbody>
</table>
<p>直接调用锁的<code>lock()</code> 和 <code>unlock()</code> 函数是危险的，因为异常或复杂的逻辑分支可能导致 <code>unlock()</code> 被跳过。因此，推荐使用锁包装器来管理锁，锁包装器采用RAII机制，能够确保安全的使用锁。常用的锁包装器有以下几种：</p>
<h4 id="stdlock_guard" class="heading-element"><span><code>std::lock_guard</code></span>
  <a href="#stdlock_guard" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>最简单、高效的锁包装器。</p>
<ul>
<li><strong>工作方式</strong>: 在构造时，它接收一个或多个互斥量（C++17 开始支持多个）并立即对它们加锁。在析构时（离开作用域），它会自动解锁。</li>
<li><strong>特点</strong>:
<ul>
<li><strong>简单粗暴</strong>: 一旦创建就加锁，没有其他多余操作。</li>
<li><strong>不可移动，不可复制</strong>: 它的所有权与作用域绑定。</li>
<li><strong>无额外开销</strong>: 通常会被编译器优化掉，性能与手动 <code>lock/unlock</code> 几乎无异，但更安全。</li>
<li><strong>独占访问</strong>: 可以确保某一时刻只有一个线程可以访问被保护的共享资源。</li>
</ul>
</li>
<li><strong>适用场景</strong>: 当你需要在一个完整的作用域内锁定一个或多个互斥量，且不需要任何高级的锁操作时。这是最常用的选择。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">some_function</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 构造时加锁，函数返回时（lock析构）自动解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 安全地访问共享资源 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 不需要手动 unlock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="stdunique_lock" class="heading-element"><span><code>std::unique_lock</code></span>
  <a href="#stdunique_lock" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>最灵活的锁包装器，相比与<code>std::lock_guard</code>提供了更多的灵活性，但也是独占访问。</p>
<ul>
<li><strong>工作方式</strong>: 提供了对互斥量所有权的完全控制。</li>
<li><strong>特点</strong>:
<ul>
<li><strong>所有权管理</strong>: <code>std::unique_lock</code> 对象拥有其管理的互斥量的锁。这个所有权可以被转移（通过移动构造或移动赋值），也可以被临时释放和重新获取。</li>
<li><strong>可移动，不可复制</strong>: 可以作为函数返回值，或存入容器中。</li>
<li><strong>支持延迟加锁</strong>: 可以在构造时不加锁（使用 <code>std::defer_lock</code>），稍后手动调用 <code>lock()</code>。</li>
<li><strong>支持尝试加锁</strong>: 可以使用 <code>try_lock()</code>、<code>try_lock_for()</code>、<code>try_lock_until()</code>。</li>
<li><strong>支持所有权转移</strong>: <code>release()</code> 方法会返回底层互斥量的指针并放弃所有权，但不会解锁。<code>std::move</code> 可以将所有权转移给另一个 <code>unique_lock</code>。</li>
</ul>
</li>
<li><strong>适用场景</strong>:
<ul>
<li><strong>与条件变量（<code>std::condition_variable</code>）配合使用</strong>：这是 <code>unique_lock</code> 最核心的用途。条件变量的 <code>wait</code> 系列函数必须接收一个 <code>std::unique_lock</code>。</li>
<li><strong>需要提前解锁</strong>: 在临界区结束前，如果某些操作不再需要锁的保护，可以调用 <code>unlock()</code> 提前释放锁。</li>
<li><strong>锁的作用域不固定</strong>: 当锁的生命周期需要跨越多个作用域或在函数间传递时。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;condition_variable&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">ready</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">worker_thread</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 构造时加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// cv.wait 会原子地：1. 解锁 a. 2. 阻塞线程 3. 被唤醒后，重新加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[]{</span> <span class="k">return</span> <span class="n">ready</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 当 wait 返回时，锁已被重新获取 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 可以在这里提前解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 执行一些不需要锁的操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="stdshared_lock" class="heading-element"><span><code>std::shared_lock</code></span>
  <a href="#stdshared_lock" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><code>std::shared_mutex</code> 的共享模式（读模式）锁包装器。</p>
<ul>
<li><strong>工作方式</strong>: 类似于 <code>unique_lock</code>，但它在构造时获取的是共享锁。</li>
<li><strong>特点</strong>:
<ul>
<li>与 <code>unique_lock</code> 类似，它也是可移动、可延迟加锁、可尝试加锁的。</li>
<li>与 <code>std::unique_lock&lt;std::shared_mutex&gt;</code> (写锁) 配合使用。</li>
</ul>
</li>
<li><strong>适用场景</strong>: 用于 <code>std::shared_mutex</code> 的读锁定。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;shared_mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ThreadSafeData</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span> <span class="n">mutex_</span><span class="p">;</span> <span class="c1">// mutable 允许在 const 成员函数中加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">read_data</span><span class="p">(</span><span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取共享锁（读锁），多个线程可以同时进入这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">shared_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">data_</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">write_data</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取独占锁（写锁），当此锁被持有时，任何其他读/写操作都会被阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">data_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="stdscoped_lock" class="heading-element"><span><code>std::scoped_lock</code></span>
  <a href="#stdscoped_lock" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><code>std::lock_guard</code> 的终极进化版，也是 C++17 中处理多互斥量锁定的最佳实践。</p>
<ul>
<li><strong>工作方式</strong>: 这是一个可变参数模板，可以同时接收任意数量的互斥量，并以<strong>避免死锁的方式</strong>将它们全部锁定。</li>
<li><strong>特点</strong>:
<ul>
<li><strong>死锁避免算法</strong>: 它内部使用了一种死锁避免算法（如 <code>std::lock</code> 函数），确保在锁定多个互斥量时不会因为加锁顺序不同而导致死锁。</li>
<li><strong>RAII 封装</strong>: 与 <code>lock_guard</code> 一样，它在构造时加锁，析构时按加锁相反的顺序解锁。</li>
<li><strong>语法简洁</strong>: 是 C++17 中锁定多个互斥量的首选方式。</li>
</ul>
</li>
<li><strong>适用场景</strong>: 当你需要同时锁定<strong>两个或更多</strong>互斥量时。</li>
</ul>
<h3 id="条件变量" class="heading-element"><span>条件变量</span>
  <a href="#%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>互斥量解决了“访问”的互斥问题，确保同一时间只有一个线程能进入临界区。但它无法解决“等待”的同步问题，例如：</p>
<ul>
<li><strong>生产者-消费者问题</strong>：当队列为空时，消费者线程如何高效地等待生产者放入数据，而不是通过一个 <code>while(true)</code> 循环不停地检查队列（这被称为“忙等待”，会浪费大量 CPU 资源）？</li>
<li><strong>任务完成通知</strong>：一个主线程如何等待多个工作线程全部完成其初始化工作后，再继续执行？</li>
</ul>
<p>条件变量正是为了解决这类问题而生的。</p>
<h4 id="核心作用" class="heading-element"><span>核心作用</span>
  <a href="#%e6%a0%b8%e5%bf%83%e4%bd%9c%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ol>
<li><strong>线程阻塞与唤醒</strong>: 允许线程在某个条件不满足时，原子地释放互斥锁并进入阻塞（睡眠）状态，从而避免了“忙等待”。当其他线程改变了该条件后，可以发送通知来唤醒等待的线程。</li>
<li><strong>线程间的同步信令</strong>: 作为一种线程间通信机制，用于同步执行流程，一个线程等待（<code>wait</code>），另一个线程通知（<code>notify</code>）。</li>
</ol>
<p>C++ 标准库提供了两种条件变量：</p>
<ol>
<li><strong><code>std::condition_variable</code></strong>: 最高效，但它<strong>必须</strong>与 <code>std::unique_lock&lt;std::mutex&gt;</code> 配合使用。这是最常用的条件变量。</li>
<li><strong><code>std::condition_variable_any</code></strong>: 更通用，可以与任何满足 <code>BasicLockable</code> 要求的锁类型配合（例如 <code>std::shared_lock</code>），但可能会有额外的性能开销。除非有特殊需求，否则应优先使用 <code>std::condition_variable</code>。</li>
</ol>
<h4 id="工作流程" class="heading-element"><span>工作流程</span>
  <a href="#%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>条件变量的典型工作流程如下，以一个等待线程（消费者）和一个通知线程（生产者）为例：</p>
<p><strong>等待线程 (Waiting Thread):</strong></p>
<ol>
<li>获取 <code>std::mutex</code> 的 <code>std::unique_lock</code>。</li>
<li><strong>检查条件</strong>。通常在一个循环中（<code>while</code> 或 <code>if</code>）检查某个共享状态（如 <code>queue.empty()</code>）。</li>
<li>如果条件<strong>不满足</strong>： a. 调用 <code>cv.wait(lock)</code>。这个调用会<strong>原子地</strong>做三件事：
i. <strong>解锁</strong>互斥量 <code>lock</code>。
ii. <strong>阻塞</strong>当前线程，使其进入睡眠状态。
iii. （当被唤醒后）<strong>重新加锁</strong>互斥量 <code>lock</code>，然后 <code>wait</code> 函数返回。 b. <code>wait</code> 返回后，循环会<strong>再次检查条件</strong>。</li>
<li>如果条件<strong>满足</strong>：线程跳出循环，继续持有锁并执行后续操作（如从队列中取数据）。</li>
<li>在离开作用域时，<code>unique_lock</code> 的析构函数会自动解锁互斥量。</li>
</ol>
<p><strong>通知线程 (Notifying Thread):</strong></p>
<ol>
<li>获取与等待线程相同的 <code>std::mutex</code> 的 <code>std::lock_guard</code> 或 <code>std::unique_lock</code>。</li>
<li><strong>修改共享状态</strong>，使得等待线程的条件得以满足（如向队列中添加数据）。</li>
<li>（可选但推荐）在修改完共享状态后，并且在解锁互斥量<strong>之前</strong>，调用 <code>cv.notify_one()</code> 或 <code>cv.notify_all()</code> 来唤醒一个或所有正在等待的线程。</li>
<li>离开作用域，锁被释放。</li>
</ol>
<h4 id="stdcondition_variable-主要成员函数" class="heading-element"><span><code>std::condition_variable</code> 主要成员函数</span>
  <a href="#stdcondition_variable-%e4%b8%bb%e8%a6%81%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong><code>wait(std::unique_lock&lt;std::mutex&gt;&amp; lock)</code></strong>: 使当前线程阻塞，直到被 <code>notify</code>。如上所述，它会自动释放锁并在此后重新获取。</li>
<li><strong><code>wait(std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate pred)</code></strong>: 这是一个重载版本，是<strong>强烈推荐</strong>的使用方式，可以有效避免虚假唤醒。<code>pred</code>一个可以调用的对象或者函数，函数或者对象没有参数并且需要返回一个bool类型的值，线程将会不停的调用<code>wait</code>函数直到该返回值为<code>true</code>。该版本的行为分为两部分：
<ul>
<li><strong>初次进入 wait() 时</strong>：
<ul>
<li>自动调用 <code>predicate()</code>；</li>
<li>若返回 <code>true</code>，<strong>直接跳出，不阻塞</strong>；</li>
<li>若返回 <code>false</code>，释放锁并阻塞线程（让出 CPU）。</li>
</ul>
</li>
<li><strong>线程被唤醒后（收到 notify）</strong>：
<ul>
<li><strong>先重新获得锁</strong>；</li>
<li>然后再次调用 <code>predicate()</code> 判断；</li>
<li>如果为 <code>true</code>：继续执行；</li>
<li>如果为 <code>false</code>：继续阻塞（避免虚假唤醒）；</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">isReady</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 下面两种写法是等价的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//写法一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutext</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">isReady</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//写法二
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutext</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="p">[]{</span><span class="k">return</span> <span class="n">isReady</span><span class="p">;});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong><code>wait_for(lock, duration)</code> / <code>wait_for(lock, duration, pred)</code></strong>: 带超时的等待。如果在指定的 <code>duration</code> 时间段内没有被唤醒（或 <code>pred</code> 未满足），<code>wait</code> 也会返回。可以通过其返回值判断是正常唤醒还是超时返回。</li>
<li><strong><code>wait_until(lock, time_point)</code> / <code>wait_until(lock, time_point, pred)</code></strong>: 与 <code>wait_for</code> 类似，但等待直到一个指定的时间点 <code>time_point</code>。</li>
<li><strong><code>notify_one()</code></strong>: 唤醒<strong>一个</strong>正在等待的线程。如果有多个线程在等待，操作系统会选择其中一个来唤醒。如果没有线程在等待，此调用无效。</li>
<li><strong><code>notify_all()</code></strong>: 唤醒<strong>所有</strong>正在等待的线程。这些被唤醒的线程会竞争同一个互斥锁，最终只有一个能立即执行，其他线程会继续阻塞在锁上。</li>
</ul>
<h2 id="设计概览" class="heading-element"><span>设计概览</span>
  <a href="#%e8%ae%be%e8%ae%a1%e6%a6%82%e8%a7%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><pre class="mermaid">classDiagram
    namespace 线程池模块 {
        class ThreadPool {
            -string m_name
            -atomic~Status~ m_status
            -mutex m_status_mutex
            -queue~Task~ m_task_queue
            -mutex m_task_queue_mutex
            -condition_variable m_task_queue_cv
            -list~WorkerThread~ m_worker_list
            -list~WorkerThread~ m_zombie_workers
            -thread m_monitor_thread
            +explicit ThreadPool(const ThreadPoolConfig& config)
            +~ThreadPool()
            +pause()
            +resume()
            +shutdown()
            +increaseThreadCount(size_t count)
            +decreaseThreadCount(size_t count)
            +setMaxTaskCount(size_t count)
            +getThreadCount() : size_t
            +getStatus() : string
            +getThreadPoolConfig() : ThreadPoolConfig
            +submit(Task) : future~Result~
            -monitorLoop()
            -adjustThreadCount()
        }

        class WorkerThread {
            -ThreadPool* m_pool_ptr
            -atomic~Status~ m_status
            -BinarySemaphore m_pause_sem
            -thread m_thread
            -atomic~time_point~ m_last_active_time
            +explicit WorkerThread(ThreadPool* pool_ptr)
            +~WorkerThread()
            +terminate()
            +pause()
            +resume()
            +getLastActiveTime() : time_point
            -isWake() : bool
            -run()
        }

        class ThreadPoolConfig {
            +size_t max_task_count
            +size_t core_thread_count
            +size_t max_thread_count
            +milliseconds keep_alive_time
            +milliseconds monitor_interval
            +bool enable_dynamic_scaling
            +operator_equals(const ThreadPoolConfig& oth) : bool
        }

        class BinarySemaphore {
            -mutex m_mutex
            -condition_variable m_cv
            -bool m_flag
            +explicit BinarySemaphore(bool initially_available)
            +acquire()
            +release()
        }
    }

    ThreadPool "1" *-- "N" WorkerThread : contains
    ThreadPool ..> ThreadPoolConfig : uses
    WorkerThread ..> ThreadPool : uses
    WorkerThread "1" *-- "1" BinarySemaphore : contains
</pre>
<template>classDiagram
    namespace 线程池模块 {
        class ThreadPool {
            -string m_name
            -atomic~Status~ m_status
            -mutex m_status_mutex
            -queue~Task~ m_task_queue
            -mutex m_task_queue_mutex
            -condition_variable m_task_queue_cv
            -list~WorkerThread~ m_worker_list
            -list~WorkerThread~ m_zombie_workers
            -thread m_monitor_thread
            +explicit ThreadPool(const ThreadPoolConfig& config)
            +~ThreadPool()
            +pause()
            +resume()
            +shutdown()
            +increaseThreadCount(size_t count)
            +decreaseThreadCount(size_t count)
            +setMaxTaskCount(size_t count)
            +getThreadCount() : size_t
            +getStatus() : string
            +getThreadPoolConfig() : ThreadPoolConfig
            +submit(Task) : future~Result~
            -monitorLoop()
            -adjustThreadCount()
        }

        class WorkerThread {
            -ThreadPool* m_pool_ptr
            -atomic~Status~ m_status
            -BinarySemaphore m_pause_sem
            -thread m_thread
            -atomic~time_point~ m_last_active_time
            +explicit WorkerThread(ThreadPool* pool_ptr)
            +~WorkerThread()
            +terminate()
            +pause()
            +resume()
            +getLastActiveTime() : time_point
            -isWake() : bool
            -run()
        }

        class ThreadPoolConfig {
            +size_t max_task_count
            +size_t core_thread_count
            +size_t max_thread_count
            +milliseconds keep_alive_time
            +milliseconds monitor_interval
            +bool enable_dynamic_scaling
            +operator_equals(const ThreadPoolConfig& oth) : bool
        }

        class BinarySemaphore {
            -mutex m_mutex
            -condition_variable m_cv
            -bool m_flag
            +explicit BinarySemaphore(bool initially_available)
            +acquire()
            +release()
        }
    }

    ThreadPool "1" *-- "N" WorkerThread : contains
    ThreadPool ..> ThreadPoolConfig : uses
    WorkerThread ..> ThreadPool : uses
    WorkerThread "1" *-- "1" BinarySemaphore : contains</template><h3 id="库架构" class="heading-element"><span>库架构</span>
  <a href="#%e5%ba%93%e6%9e%b6%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>线程池采用了模块化设计，主要由下面三个核心组件构成：</p>
<ol>
<li><strong><code>ThreadPool</code> 类</strong>：作为用户直接交互的接口，负责任务调度、线程管理等核心功能。用户通过创建 <code>ThreadPool</code> 实例来提交任务、控制线程池状态、并获取线程池相关信息。</li>
<li><strong><code>ThreadPool::WorkerThread</code> 类</strong>：作为线程池内部的工作单元，每个 <code>ThreadPool::WorkerThread</code> 对象代表一个独立的工作线程，负责从任务队列中取出任务并执行。</li>
<li><strong>辅助工具</strong>：包括同步原语（如互斥锁、条件变量、信号量等）以及状态管理机制，它们为线程池和工作线程之间的通信、任务同步、状态变更等操作提供了必要的支撑。</li>
</ol>
<p>各组件间的关系如下：</p>
<ul>
<li><code>ThreadPool</code> 类维护一个工作线程列表 <code>std::list&lt;WorkerThread&gt;</code>，并通过同步原语控制任务队列的访问与状态变更。并通过<code>ThreadPool::WorkerThread</code>提供的接口，对工作线程发出各种指令（如暂停、恢复、终止等）。</li>
<li><code>ThreadPool::WorkerThread</code> 类定义一系列接口供 <code>ThreadPool</code> 类使用，从而能够获取待执行任务、更新自身状态。</li>
<li>辅助工具贯穿于整个库的设计与实现中，确保并发环境下的数据一致性与操作安全性。</li>
</ul>
<h3 id="状态转换" class="heading-element"><span>状态转换</span>
  <a href="#%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>线程池的状态转换如下所示：</p>
<pre class="mermaid">stateDiagram-v2
    direction LR
    [*] --> RUNNING: 初始化

    RUNNING --> PAUSED: 调用 pause()
    PAUSED --> RUNNING: 调用 resume()

    RUNNING --> SHUTDOWN: 调用 shutdown()
    PAUSED --> RUNNING: (1)shutdown()内部先调用resumeWithoutStatusLock()
    RUNNING --> SHUTDOWN: (2)再自动进入

    SHUTDOWN --> TERMINATING: 任务队列为空
    TERMINATING --> TERMINATED: 全部工作线程 join

    TERMINATED --> [*]
</pre>
<template>stateDiagram-v2
    direction LR
    [*] --> RUNNING: 初始化

    RUNNING --> PAUSED: 调用 pause()
    PAUSED --> RUNNING: 调用 resume()

    RUNNING --> SHUTDOWN: 调用 shutdown()
    PAUSED --> RUNNING: (1)shutdown()内部先调用resumeWithoutStatusLock()
    RUNNING --> SHUTDOWN: (2)再自动进入

    SHUTDOWN --> TERMINATING: 任务队列为空
    TERMINATING --> TERMINATED: 全部工作线程 join

    TERMINATED --> [*]</template><p>工作线程的状态转换如下所示：</p>
<pre class="mermaid">stateDiagram-v2
    direction LR
    [*] --> RUNNING: 初始化

    RUNNING --> PAUSED: 调用 pause()
    PAUSED --> RUNNING: 调用 resume()

    RUNNING --> TERMINATING: 调用 terminate()
    PAUSED --> TERMINATING: 调用 terminate()

    TERMINATING --> TERMINATED: run() 循环结束
    TERMINATED --> [*]
</pre>
<template>stateDiagram-v2
    direction LR
    [*] --> RUNNING: 初始化

    RUNNING --> PAUSED: 调用 pause()
    PAUSED --> RUNNING: 调用 resume()

    RUNNING --> TERMINATING: 调用 terminate()
    PAUSED --> TERMINATING: 调用 terminate()

    TERMINATING --> TERMINATED: run() 循环结束
    TERMINATED --> [*]</template><h3 id="线程数量增减" class="heading-element"><span>线程数量增减</span>
  <a href="#%e7%ba%bf%e7%a8%8b%e6%95%b0%e9%87%8f%e5%a2%9e%e5%87%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>本线程池实现了两种方式的线程池数量增减，第一种为<strong>用户手动</strong>调用<code>increaseThreadCount</code>和<code>decreaseThreadCount</code>函数来进行线程数量的增减：</p>
<pre class="mermaid">sequenceDiagram
    actor User as 用户
    participant TP as ThreadPool
    participant WT as WorkerThread

    User->>TP: increaseThreadCount(N)
    activate TP
    TP->>TP: 1. 锁定状态锁 (m_status_mutex)
    TP->>TP: 2. 检查状态是否为 RUNNING/PAUSED
    loop N 次
        TP->>WT: 3. new WorkerThread(this)
        activate WT
        note right of WT: 构造函数启动 std::thread, <br/>线程进入 RUNNING 状态
        WT-->>TP: 构造完成
        deactivate WT
    end
    TP->>TP: 4. 解除状态锁
    deactivate TP
    User->>TP: decreaseThreadCount(N)
    activate TP
    TP->>TP: 1. 锁定状态锁 (m_status_mutex)
    TP->>TP: 2. 检查状态是否为 RUNNING/PAUSED
    loop N 次
        TP->>WT: 3. worker.terminate()
        activate WT
        note right of WT: 状态变为 TERMINATING, <br/>并唤醒自己准备退出
        WT-->>TP: terminate() 返回
        deactivate WT
        TP->>TP: 4. 将 WorkerThread 移入僵尸列表
    end
    TP->>TP: 5. 解除状态锁
    deactivate TP
</pre>
<template>sequenceDiagram
    actor User as 用户
    participant TP as ThreadPool
    participant WT as WorkerThread

    User->>TP: increaseThreadCount(N)
    activate TP
    TP->>TP: 1. 锁定状态锁 (m_status_mutex)
    TP->>TP: 2. 检查状态是否为 RUNNING/PAUSED
    loop N 次
        TP->>WT: 3. new WorkerThread(this)
        activate WT
        note right of WT: 构造函数启动 std::thread, <br/>线程进入 RUNNING 状态
        WT-->>TP: 构造完成
        deactivate WT
    end
    TP->>TP: 4. 解除状态锁
    deactivate TP
    User->>TP: decreaseThreadCount(N)
    activate TP
    TP->>TP: 1. 锁定状态锁 (m_status_mutex)
    TP->>TP: 2. 检查状态是否为 RUNNING/PAUSED
    loop N 次
        TP->>WT: 3. worker.terminate()
        activate WT
        note right of WT: 状态变为 TERMINATING, <br/>并唤醒自己准备退出
        WT-->>TP: terminate() 返回
        deactivate WT
        TP->>TP: 4. 将 WorkerThread 移入僵尸列表
    end
    TP->>TP: 5. 解除状态锁
    deactivate TP</template><p>第二种为启用监控线程（需要在初始化线程池时指定参数<code>enable_dynamic_scaling</code>参数为<code>true</code>），监控线程将会根据线程池的负载<strong>自动增减</strong>工作线程：</p>
<pre class="mermaid">graph TD
    subgraph MonitorThread [监控线程: monitorLoop]
        A(启动监控线程) --> B(循环开始);

        B --> C{"m_terminating_flag为true?"};
        C -- 是 --> Z([线程终止]);
        C -- 否 --> D[等待monitor_interval时间或被唤醒];
        
        D --> F{"should_terminate为true?"};
        F -- 是 --> Z;
        F -- 否 --> I["调用adjustThreadCount()"];
        
        I --> B;
    end

    subgraph adjustThreadCount [调整线程数逻辑]
        I --> J[获取线程池状态锁];
        J --> K{"当前状态是RUNNING或PAUSED?"};
        K -- 否 --> L[释放status_lock锁];
        L --> M(调整结束);
        
        K -- 是 --> N[获取相关信息];
        
        N --> O{"满足扩容条件?"};
        O -- 是 --> P["调用increaseThreadCountWithoutStatusLock(1)"];
        P --> L;
        
        O -- 否 --> Q{"满足缩容条件?"};
        Q -- 否 --> L;
        
        Q -- 是 --> R[计算超时空闲线程数];
        
        R --> W{"超时空闲线程数 > 0?"};
        W -- 是 --> X["调用decreaseThreadCountWithoutStatusLock(N)"];
        X --> L;
        W -- 否 --> L;
    end
</pre>
<template>graph TD
    subgraph MonitorThread [监控线程: monitorLoop]
        A(启动监控线程) --> B(循环开始);

        B --> C{"m_terminating_flag为true?"};
        C -- 是 --> Z([线程终止]);
        C -- 否 --> D[等待monitor_interval时间或被唤醒];
        
        D --> F{"should_terminate为true?"};
        F -- 是 --> Z;
        F -- 否 --> I["调用adjustThreadCount()"];
        
        I --> B;
    end

    subgraph adjustThreadCount [调整线程数逻辑]
        I --> J[获取线程池状态锁];
        J --> K{"当前状态是RUNNING或PAUSED?"};
        K -- 否 --> L[释放status_lock锁];
        L --> M(调整结束);
        
        K -- 是 --> N[获取相关信息];
        
        N --> O{"满足扩容条件?"};
        O -- 是 --> P["调用increaseThreadCountWithoutStatusLock(1)"];
        P --> L;
        
        O -- 否 --> Q{"满足缩容条件?"};
        Q -- 否 --> L;
        
        Q -- 是 --> R[计算超时空闲线程数];
        
        R --> W{"超时空闲线程数 > 0?"};
        W -- 是 --> X["调用decreaseThreadCountWithoutStatusLock(N)"];
        X --> L;
        W -- 否 --> L;
    end</template><h3 id="任务调度与执行" class="heading-element"><span>任务调度与执行</span>
  <a href="#%e4%bb%bb%e5%8a%a1%e8%b0%83%e5%ba%a6%e4%b8%8e%e6%89%a7%e8%a1%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>完整的任务生命周期如下所示：</p>
<pre class="mermaid">sequenceDiagram
    actor Client as "任务提交者"
    participant TP as "ThreadPool"
    participant TQ as "任务队列"
    participant Future as "std::future"
    participant WT as "WorkerThread (空闲)"

    Client->>TP: submit(function, args...)
    activate TP
    TP->>TP: 1. 封装为 packaged_task
    TP->>Future: 2. task.get_future()
    activate Future
    Future-->>TP: future 对象
    deactivate Future
    TP->>TP: 3. 再次封装为 std::function&lt;void()&gt;
    TP->>TQ: 4. 将任务加入任务队列
    deactivate TP
    
    TP->>WT: 5. m_task_queue_cv.notify_one()
    TP-->>Client: 6. 返回 future 对象

    activate WT
    WT->>TQ: 7. lock(), task = task_queue.front()
    activate TQ
    TQ-->>WT: task
    WT->>TQ: 8. task_queue.pop(), unlock()
    deactivate TQ
    WT->>WT: 9. 执行任务
    note over WT, Future: 任务结果/异常被存入<br/>与 future 关联的共享状态中
    deactivate WT

    Client->>Future: get() [阻塞等待结果]
    activate Future
    Future-->>Client: 返回任务结果或抛出异常
    deactivate Future
</pre>
<template>sequenceDiagram
    actor Client as "任务提交者"
    participant TP as "ThreadPool"
    participant TQ as "任务队列"
    participant Future as "std::future"
    participant WT as "WorkerThread (空闲)"

    Client->>TP: submit(function, args...)
    activate TP
    TP->>TP: 1. 封装为 packaged_task
    TP->>Future: 2. task.get_future()
    activate Future
    Future-->>TP: future 对象
    deactivate Future
    TP->>TP: 3. 再次封装为 std::function&lt;void()&gt;
    TP->>TQ: 4. 将任务加入任务队列
    deactivate TP
    
    TP->>WT: 5. m_task_queue_cv.notify_one()
    TP-->>Client: 6. 返回 future 对象

    activate WT
    WT->>TQ: 7. lock(), task = task_queue.front()
    activate TQ
    TQ-->>WT: task
    WT->>TQ: 8. task_queue.pop(), unlock()
    deactivate TQ
    WT->>WT: 9. 执行任务
    note over WT, Future: 任务结果/异常被存入<br/>与 future 关联的共享状态中
    deactivate WT

    Client->>Future: get() [阻塞等待结果]
    activate Future
    Future-->>Client: 返回任务结果或抛出异常
    deactivate Future</template><h2 id="主要实现" class="heading-element"><span>主要实现</span>
  <a href="#%e4%b8%bb%e8%a6%81%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="submit函数" class="heading-element"><span><code>submit</code>函数</span>
  <a href="#submit%e5%87%bd%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>线程池设计的基本理念就是：<strong>任务入队时就应该已经具备所有执行信息（函数体 + 参数）</strong>，工作线程只负责调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @brief 提交任务到任务队列, 并返回一个 future 对象以获取执行结果
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @details 支持任意函数签名及参数组合. 内部将任务封装为无参的 `std::function&lt;void()&gt;`
</span></span></span><span class="line"><span class="cl"><span class="cm">     *          形式, 统一工作线程的任务调度格式. 任务将在后台线程异步执行.
</span></span></span><span class="line"><span class="cl"><span class="cm">     *          暂停态也可以提交任务, 但不会执行新任务
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @note 如果某个参数是引用类型, 则在提交任务时要用 std::ref(data) 的形式来明确告知submit函数传引用
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @tparam F 可调用对象的类型(函数指针, lambda, std::function等)
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @tparam Args 可调用对象 f 所需的参数类型
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param[in] f 要执行的函数对象
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param[in] args 要传递给函数 f 的参数(可变参数包)
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return 返回一个 future 对象
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="n">submit</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 加锁, 防止在提交任务过程中线程池状态发生变化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">status_lock</span><span class="p">(</span><span class="n">m_status_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">Status</span> <span class="n">current_status</span> <span class="o">=</span> <span class="n">m_status</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 检查当前线程池状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">current_status</span> <span class="o">!=</span> <span class="n">Status</span><span class="o">::</span><span class="n">RUNNING</span> <span class="o">&amp;&amp;</span> <span class="n">current_status</span> <span class="o">!=</span> <span class="n">Status</span><span class="o">::</span><span class="n">PAUSED</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">VELOX_ERROR</span><span class="p">(</span><span class="s">&#34;[submit error]: ThreadPool is in a state where it cannot submit tasks&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&#34;[submit error]: ThreadPool is in a state where it cannot submit tasks&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 判断任务队列是否已满
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">isTaskQueueFull</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">VELOX_ERROR</span><span class="p">(</span><span class="s">&#34;[submit error]: task queue is full&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&#34;[submit error]: task queue is full&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">using</span> <span class="n">return_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">auto</span> <span class="n">args_tuple</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 将提交的任务进行双重包装:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 1. 内层 lambda 将 f 和其参数封装成一个无参可调用的对象. 统一了工作线程统执行任务的方式(通过()来执行)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 2. 外层 std::packaged_task 封装该 lambda. 这样做能够获取 future, 以便任务提交者能够获取执行结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">auto</span> <span class="n">task_ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">return_type</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="p">[</span><span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">tuple</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">args_tuple</span><span class="p">)]()</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="n">return_type</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">apply</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">tuple</span><span class="p">);</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 获取该任务的 future, 通过该变量获取任务执行结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">return_type</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">task_ptr</span><span class="o">-&gt;</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 将任务提交到任务队列中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_task_queue_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 进行类型擦除, 将 packaged_task 封装为 void() 类型的 lambda 并加入任务队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 使得任务队列能够存储不同返回类型的函数, 提高了通用性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">m_task_queue</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="n">task_ptr</span><span class="p">]()</span> <span class="p">{</span> <span class="p">(</span><span class="o">*</span><span class="n">task_ptr</span><span class="p">)();</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">m_task_queue_cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">future</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>代码中的注释已经详细的说明了每一行代码的作用，那么下面我们将详细说明一下这个函数的设计思路：</p>
<ol>
<li>
<p><strong>如何设计任务队列？</strong>
首先，线程池的任务队列必须能够存储<strong>各种各样</strong>的任务，那么就意味着我们只能往里面塞 <strong><code>void()</code> 类型</strong>的任务对象，换句话说，所有任务都必须 <strong>“类型擦除”</strong> 为一个 <code>void()</code> 可调用对象。因此，任务队列存储的类型就应该为<code>std::function&lt;void()&gt;</code>，这样就能够存储任何任务了，且工作线程也只管执行任务，无需关心任务的参数和返回值。</p>
</li>
<li>
<p><strong>如何将原始函数封装成<code>std::function&lt;void()&gt;</code> 呢？</strong>
任务提交者肯定都是想要知道任务执行结果的，而工作线程执行的是<code>void()</code>，有什么优雅的方式能够获取执行结果呢？那就是使用<code>std::packaged_task</code>来进行封装! 因为该类的<code>get_future()</code> 方法会返回一个 <code>std::future</code> 对象，可以获取任务的执行结果。</p>
<p>所以，我们先使用一个 <code>lambda</code> 将原始任务封装成一个<strong>无参任务</strong>，再使用 <code>std::packaged_task</code> 对无参任务进行封装，最后在入队时将其封装成一个<code>void()</code>对象。</p>
<p>这里有三个需要注意的地方：</p>
<p><mark>1. 为什么<code>std::packaged_task</code> 不直接将无参任务封装成<code>void()</code>?</mark></p>
<p>因为当任务有返回值时，我们想要能够获取返回值。用 <code>packaged_task&lt;void()&gt;</code> 那么返回的 <code>future</code>类型就是<code>std::future&lt;void&gt;</code>，任务提交者就无法获取任务执行结果了。</p>
<p><mark>2. 为什么要用 <code>lambda</code> 将原始任务封装成一个无参任务再由<code>std::packaged_task</code>封装？</mark></p>
<p>因为，这种做法是标准做法，其提供了更直接的参数绑定，可以保持任务签名一致性 (<code>void()</code>)，代码结构更加清晰健壮。当然也可以使用<code>std::packaged_task</code>封装原始函数，在后续再把task封装成<code>void()</code>，但是不推荐这样做。</p>
<p><mark>3. 为什么使用 <code>shared_ptr</code> 管理 <code>packaged_task</code>？</mark></p>
<p>最主要的原因是 <strong><code>packaged_task</code> 对象必须在 <code>submit</code> 函数返回后继续存活，直到某个工作线程最终执行它。</strong></p>
<p>如果使用局部变量 <code>auto task = ...</code>，这个 <code>task</code> 对象会在 <code>submit</code> 函数结束时被销毁，当工作线程调用 <code>task()</code> 时，它访问的是一个<strong>已经被销毁的对象</strong>。这是典型的<strong>悬挂指针/引用</strong>问题，会导致<strong>未定义行为</strong>，程序很可能会立即崩溃。</p>
<p>此外，<code>std::function</code> 要求其内部存储的可调用对象是<strong>可拷贝的</strong>，而一个捕获了 <code>std::unique_ptr</code> 的 lambda 自身是不可拷贝的，所以不能使用<code>std::unique_ptr</code>。</p>
</li>
</ol>
<p><strong>注意：</strong> 如果提交的任务有引用参数的话，要使用 <strong><code>std::ref(data)</code></strong> 的形式来传，因为<code>Args&amp;&amp;... args</code> 是值传递，实参会被 按值 传递进任务中（即复制），除非你明确告诉它传“引用”。</p>
<h3 id="工作线程执行逻辑" class="heading-element"><span>工作线程执行逻辑</span>
  <a href="#%e5%b7%a5%e4%bd%9c%e7%ba%bf%e7%a8%8b%e6%89%a7%e8%a1%8c%e9%80%bb%e8%be%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>工作线程就是不断执行定义的循环逻辑，直到被线程池终止。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">ThreadPool</span><span class="o">::</span><span class="n">WorkerThread</span><span class="o">::</span><span class="n">run</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// --- 阶段1: 检查自身状态 ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 状态互斥量上锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span> <span class="n">status_lock</span><span class="p">(</span><span class="n">m_status_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 处理终止
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">m_status</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span> <span class="o">==</span> <span class="n">Status</span><span class="o">::</span><span class="n">TERMINATING</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">m_status</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">Status</span><span class="o">::</span><span class="n">TERMINATED</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 处理暂停
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">m_status</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span> <span class="o">==</span> <span class="n">Status</span><span class="o">::</span><span class="n">PAUSED</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">status_lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>   <span class="c1">// 手动释放状态锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">m_pause_sem</span><span class="p">.</span><span class="n">acquire</span><span class="p">();</span>  <span class="c1">// 等待信号量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// --- 阶段2: 处于运行态, 获取任务 ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 任务队列上锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span> <span class="n">queue_lock</span><span class="p">(</span><span class="n">m_pool_ptr</span><span class="o">-&gt;</span><span class="n">m_task_queue_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 判断是否 wait
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">isWake</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">m_pool_ptr</span><span class="o">-&gt;</span><span class="n">m_task_queue_cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">queue_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/*--------------- 判断被唤醒的原因 ---------------*/</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 线程处于非运行态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">shared_lock</span> <span class="n">status_lock</span><span class="p">(</span><span class="n">m_status_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">m_status</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Status</span><span class="o">::</span><span class="n">RUNNING</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 线程池要停止了, 且队列已空, 则直接准备退出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">m_pool_ptr</span><span class="o">-&gt;</span><span class="n">m_terminating_flag</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">m_pool_ptr</span><span class="o">-&gt;</span><span class="n">m_task_queue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span> <span class="n">status_lock</span><span class="p">(</span><span class="n">m_status_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="n">m_status</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">Status</span><span class="o">::</span><span class="n">TERMINATING</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 线程处于运行态, 对于 终止 + 非空 和 非终止 + 非空 的情况我们都需要取任务执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">task</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m_pool_ptr</span><span class="o">-&gt;</span><span class="n">m_task_queue</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">m_pool_ptr</span><span class="o">-&gt;</span><span class="n">m_task_queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">m_pool_ptr</span><span class="o">-&gt;</span><span class="n">m_task_queue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">m_pool_ptr</span><span class="o">-&gt;</span><span class="n">m_task_queue_empty_cv</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// --- 阶段3: 执行任务(无锁状态) ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">m_pool_ptr</span><span class="o">-&gt;</span><span class="n">m_busy_thread_count</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">try</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">task</span><span class="p">();</span>  <span class="c1">// 执行任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">VELOX_ERROR</span><span class="p">(</span><span class="s">&#34;Task execution failed: {}&#34;</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">m_pool_ptr</span><span class="o">-&gt;</span><span class="n">m_busy_thread_count</span><span class="p">.</span><span class="n">fetch_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">m_last_active_time</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">VELOX_INFO</span><span class="p">(</span><span class="s">&#34;WorkerThread terminated&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="使用示例" class="heading-element"><span>使用示例</span>
  <a href="#%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;threadpool.hpp&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">velox</span><span class="o">::</span><span class="n">threadpool</span><span class="o">::</span><span class="n">ThreadPoolConfig</span> <span class="n">pool_config</span><span class="p">;</span> <span class="c1">// 定义线程池配置变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 指定各项配置的值, 不指定将会使用默认值, 各项默认值可查阅 config/threadpool.yml 文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pool_config</span><span class="p">.</span><span class="n">max_task_count</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pool_config</span><span class="p">.</span><span class="n">core_thread_count</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pool_config</span><span class="p">.</span><span class="n">max_thread_count</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 定义线程池变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ThreadPool</span><span class="o">&gt;</span> <span class="n">pool</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ThreadPool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pool_config</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 加载指定目录下的配置文件(可选)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// velox::config::Config::loadFromConfDir(&#34;test/threadpool&#34;);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 提交一个返回 int 的普通函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">future1</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">submit</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 提交一个无返回值的 Lambda 表达式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">future2</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">submit</span><span class="p">([]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">500</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Task [lambda]: Finished.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 提交多个任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">futures</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">futures</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">submit</span><span class="p">([</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Task [loop &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;]: Running in thread &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">200</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 暂停线程池, 线程池处于暂停态时只会接受任务, 不会执行任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pool</span><span class="o">-&gt;</span><span class="n">pause</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 在暂停期间提交一个任务，它会被接收但不会立即执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">future_paused</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">submit</span><span class="p">([]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;This task was submitted while paused.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="c1">// 等待一段时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将线程池恢复运行态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pool</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取任务结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Result of add(10, 20) is &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">future1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 等待 lambda 任务完成 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">future2</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 等待循环中的任务并打印结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">futures</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Result of loop task &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; is &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">futures</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">future_paused</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">All tasks finished.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 关闭线程池, 但也可以不调用此函数, 由线程池类的析构函数完成资源的释放
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pool</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title="更新于 2025-08-10 20:28:15">更新于 2025-08-10&nbsp;</span>
      </div></div><div class="post-info-line">
        <div class="post-info-md"></div>
        <div class="post-info-share">
          <span></span>
        </div>
      </div></div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href="/tags/velox%E6%A8%A1%E5%9D%97/" class="post-tag" title="标签 - Velox模块">Velox模块</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/posts/6c7e777/" class="post-nav-item" rel="prev" title="Cmake学习笔记"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>Cmake学习笔记</a>
      <a href="/posts/1235a2f/" class="post-nav-item" rel="next" title="Velox_日志模块">Velox_日志模块<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
        Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk" rel="external nofollow noopener noreferrer">Gitalk</a>.
      </noscript></div></article>

  <aside class="toc" id="toc-auto" aria-label="目录"><h2 class="toc-title">目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside></main><footer class="footer">
    <div class="footer-container"><div class="footer-line statistics"><span class="site-time" title='网站运行中……'><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden="true"></i><span class="ms-1 d-none">站点已运行:</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line powered">由 <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer" title="Hugo 0.128.2"><img class="hugo-icon" src="/images/hugo.min.svg" alt="Hugo logo" /> Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/hugo-fixit/FixIt" target="_blank" rel="external" title="FixIt v0.3.8"><img class="fixit-icon" src="/images/fixit.min.svg" alt="FixIt logo" /> FixIt</a>
        </div><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2024 - 2025</span><span class="author" itemprop="copyrightHolder">
              <a href="https://github.com/YouZhiZheng"target="_blank" rel="external nofollow noopener noreferrer">zyz</a></span>
            <span class="license footer-divider">
              <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener noreferrer">
                CC BY-NC 4.0
              </a>
            </span></div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="回到顶部"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric">0%</span>
        </div><div class="fixed-button view-comments d-none" role="button" aria-label="查看评论"><i class="fa-solid fa-comment fa-fw" aria-hidden="true"></i></div></div><div id="mask"></div><div class="reading-progress-bar" style="left: 0;top: 0;"></div><noscript>
    <div class="noscript-warning">该网站在启用 JavaScript 的情况下效果最佳。</div>
  </noscript>
</div><script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
    window.mermaid = mermaid;
    window.mermaid.themes = ["default","dark"];
</script><link rel="stylesheet" href="/lib/gitalk/gitalk.min.css"><link rel="stylesheet" href="/lib/lightgallery/css/lightgallery-bundle.min.css"><link rel="preload" href="/lib/katex/katex.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/katex/katex.min.css"></noscript><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script src="/lib/gitalk/gitalk.min.js"></script><script src="/lib/autocomplete/autocomplete.min.js" defer></script><script src="/lib/fuse/fuse.min.js" defer></script><script src="/lib/lightgallery/lightgallery.min.js" defer></script><script src="/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js" defer></script><script src="/lib/lightgallery/plugins/zoom/lg-zoom.min.js" defer></script><script src="/lib/katex/katex.min.js" defer></script><script src="/lib/katex/auto-render.min.js" defer></script><script src="/lib/katex/mhchem.min.js" defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script>window.config={"code":{"copyTitle":"复制到剪贴板","editLockTitle":"锁定可编辑代码块","editUnLockTitle":"解锁可编辑代码块","editable":true,"maxShownLines":10},"comment":{"enable":true,"expired":false,"gitalk":{"admin":["YouZhiZheng"],"clientID":"Ov23livVaozXEe7YADcG","clientSecret":"6ae375086f323067720e32edf43469d6491964ed","id":"2025-08-10T20:28:15+08:00","owner":"YouZhiZheng","repo":"MyBlogComment","title":"Velox_线程池模块"}},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验。"},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"lightgallery":true,"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"distance":100,"findAllMatches":false,"fuseIndexURL":"/index.json","highlightTag":"em","ignoreFieldNorm":false,"ignoreLocation":false,"isCaseSensitive":false,"location":0,"maxResultLength":10,"minMatchCharLength":2,"noResultsFound":"没有找到结果","snippetLength":30,"threshold":0.3,"type":"fuse","useExtendedSearch":false},"siteTime":"2024-07-01T09:00:00+08:00","version":"v0.3.8"};</script><script src="/js/theme.min.js" defer></script></body>
</html>
